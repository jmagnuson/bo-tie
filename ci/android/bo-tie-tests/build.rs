extern crate bindgen;

use std::env;
use std::fs::File;
use std::io::prelude::*;
use std::path::{Path,PathBuf};
use std::process::Command;

static KOTLIN_FILE: &'static str = "src/kotlin/Interface.kt";

static CLASS_PATH: &'static str = "botie.testproject.Interface";

static HEADER: &'static str = "botie_testproject_Interface.h";

static JDK_INCLUDE: &'static str = "/usr/lib/jvm/java-8-openjdk-amd64/include";

static BINDINGS_FILE: &'static str = "src/jni_gen.rs";

#[cfg(any(target_os = "linux", target_os = "android"))]
static MD_PATH: &'static str = "/linux";

#[cfg(target_os = "windows")]
static MD_PATH: &'static str = "/win*";

#[cfg(target_os = "macos")]
static MD_PATH: &'static str = "/macos";

fn main() {

    println!("cargo:rerun-if-changed={}", KOTLIN_FILE);

    let output_path = env::var("OUT_DIR").unwrap();

    let jni_inc_path: String = match env::var_os("JNI_INCLUDE") {
        Some(path) => path.into_string().unwrap(),
        None => if Path::new(JDK_INCLUDE).exists() {
            String::from(JDK_INCLUDE)
        } else if let Some(java_home) = env::var_os("JAVA_HOME") {

            let path = format!("{}/include", java_home.clone().into_string().unwrap());

            if Path::new(&path).exists() {
                path
            }
            else {
                panic!("JAVA_HOME is defined (as '{}'), but path '{}' doesn't exist",
                    java_home.into_string().unwrap(), path
                );
            }
        } else {
            panic!("The include path to the jni header files is not defined (build.rs default \
                location is {} which doesn't exist on your system). Set the env 'JNI_INCLUDE' \
                to the jni header files or set JAVA_HOME to the base directory of the jdk",
                JDK_INCLUDE
            );
        }
    };

    let bindgen_header_path = [output_path.as_str(), "bindings.h"].iter().collect::<PathBuf>();

    let jni_file_path = [output_path.as_str(), HEADER].iter().collect::<PathBuf>();

    let mut bindgen_header_file = File::create(bindgen_header_path.clone()).unwrap();

    bindgen_header_file.set_len(0).unwrap();
    write!(bindgen_header_file, r#"#include "{}""#, jni_file_path.display() ).unwrap();
    write!(bindgen_header_file, "\n").unwrap();
    bindgen_header_file.flush().unwrap();

    let kotlinc_output = Command::new("kotlinc")
        .args(&["-d", &output_path, "-no-reflect", "-no-stdlib"])
        .arg(KOTLIN_FILE)
        .output()
        .expect("Cannot find kotlinc");

    if ! kotlinc_output.status.success() {
        panic!("{}", String::from_utf8(kotlinc_output.stderr).unwrap() );
    }

    let javah_output = Command::new("javah")
        .args(&["-d", &output_path, "-cp", &output_path ])
        .arg(CLASS_PATH)
        .output()
        .expect("Java JDK not installed (uses Java v1.8)");

    if ! javah_output.status.success() {
        panic!("{}", String::from_utf8(javah_output.stderr).unwrap() );
    }

    let generation = bindgen::Builder::default()
                     .header(bindgen_header_path.to_str().unwrap())
                     .generate_comments(true)
                     .layout_tests(false)
                     .whitelist_recursively(false)
                     .whitelist_function(".*testInit")
                     .whitelist_function(".*runTests")
                     .clang_arg(format!("{}{}", "-I", jni_inc_path))
                     .clang_arg(format!("{}{}{}", "-I", jni_inc_path, MD_PATH))
                     .generate()
                     .expect("Couldn't create binding generation");

    let mut bindings_file = File::create(BINDINGS_FILE).expect("Couldn't create bindings file");

    let mut bindings = generation.to_string()
        .split("\n")
        .map(|line| {
            let mut new_line = String::from("    ");
            new_line.push_str(line);
            new_line.push('\n');
            new_line
        })
        .collect::<String>();

    // Replace              With
    // extern "C" {         #[no_mangle]
    // *mut JNIEnv          ::jni::JNIEnv
    // jclass               ::jni::objects::JClass
    // 'return'             ::jni::sys::'return'
    while let Some(pos) = bindings.find(r#"extern "C" {"#) {
        bindings::replace_extern_c(pos, &mut bindings);
        bindings::replace_next( pos, &mut bindings, "*mut JNIEnv", "::jni::JNIEnv");
        bindings::replace_next( pos, &mut bindings, "jobject", "::jni::objects::JClass");
        bindings::replace_return( pos, &mut bindings)
    }

    let bindings_contents = format!("\
        /// This file is generated by the build script of this crate, do not edit. Edit src/kotlin/Interface.kt\n\
        /// to alter/generate native methods for the java native interface.\n\
        \n\
        #[allow(non_snake_case)]\n\
        pub trait TestJNI {{\n\
            {}\
        }}\n\
        ",
        bindings);

    bindings_file.set_len(0).unwrap();
    bindings_file.write_all(bindings_contents.as_bytes()).unwrap();
}

mod bindings {
    /// replace 'extern "C" {...}' with #[no_mangle]...
    pub fn replace_extern_c( pos: usize, bindings: &mut String ) {
        let next_fn_kwrd = bindings[pos..].find("fn").unwrap() + pos;

        bindings.replace_range(pos..next_fn_kwrd, "#[no_mangle]\n    extern \"system\" ");

        let next_semi_colon = bindings[pos..].find(";").unwrap() + pos;

        let next_end_line_1 = bindings[next_semi_colon..].find("\n").unwrap() + next_semi_colon;

        let next_close_bracket = bindings[next_end_line_1..].find("}").unwrap() + next_end_line_1;

        let next_end_line_2 = bindings[next_close_bracket..].find("\n").unwrap() + next_close_bracket;

        bindings.replace_range((next_end_line_1 + 1)..=(next_end_line_2), "\n");
    }

    pub fn replace_next<'a>( pos: usize, bindings: &mut String, to_replace: &'a str, with: &'a str ) {
        let next_mut_jnienv = bindings[pos..].find(to_replace).unwrap() + pos;

        bindings.replace_range(next_mut_jnienv..(to_replace.len() + next_mut_jnienv), with);
    }

    pub fn replace_return( pos: usize, bindings: &mut String ) {
        let next_left_arrow = bindings[pos..].find("->").unwrap() + pos;

        let next_semi_colon = bindings[pos..].find(";").unwrap() + pos;

        let replace_range = ( next_left_arrow + "->".len() )..next_semi_colon;

        bindings.replace_range(
            replace_range.clone(),
            replace_sys_type( &bindings[replace_range].trim() )
        );
    }

    fn replace_sys_type( ret_type: &str ) -> &'static str {
        // First character is a space for all match values so that it looks good when inserted as
        // the return type.
        match ret_type {
            "jarray" => " ::jni::sys::jarray",
            "jboolean" => " ::jni::sys::jboolean",
            "jbooleanArray" => " ::jni::sys::jbooleanArray",
            "jbyte" => " ::jni::sys::jbyte",
            "jbyteArray" => " ::jni::sys::jbyteArray",
            "jchar" => " ::jni::sys::jchar",
            "jcharArray" => " ::jni::sys::jcharArray",
            "jclass" => " ::jni::sys::jclass",
            "jdouble" => " ::jni::sys::jdouble",
            "jdoubleArray" => " ::jni::sys::jdoubleArray",
            "jfieldID" => " ::jni::sys::jfieldID",
            "jfloat" => " ::jni::sys::jfloat",
            "jfloatArray" => " ::jni::sys::jfloatArray",
            "jint" => " ::jni::sys::jint",
            "jintArray" => " ::jni::sys::jintArray",
            "jlong" => " ::jni::sys::jlong",
            "jlongArray" => " ::jni::sys::jlongArray",
            "jmethodID" => " ::jni::sys::jmethodID",
            "jobject" => " ::jni::sys::jobject",
            "jobjectArray" => " ::jni::sys::jobjectArray",
            "jshort" => " ::jni::sys::jshort",
            "jshortArray" => " ::jni::sys::jshortArray",
            "jstring" => " ::jni::sys::jstring",
            _ => panic!("Unknown return type for jni method: {}", ret_type)
        }
    }
}
