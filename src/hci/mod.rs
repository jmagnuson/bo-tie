//! In Bluez there is a "manager" for the interface to the bluetooth hardware
//!
//! This is really the api to the HCI (host controller interface) of the bluetooth device (as per
//! the bluetooth specification). This module is further broken up into modules for OGFs (OpCode
//! group field(s)).


macro_rules! hci_future_output {
    () => { ::core::result::Result<crate::hci::events::EventsData, impl ::core::fmt::Display + ::core::fmt::Debug> }
}

mod opcodes;
pub mod common;
pub mod error;
#[macro_use] pub mod events;

#[cfg(unix)] mod unix;

use core::fmt::Debug;
use core::fmt::Display;
use core::future::Future;
use core::time::Duration;

/// Used to get the information required for sending a command from the host to the controller
///
/// The type Parameter should be a packed structure of the command's parameters
trait CommandParameters {
    /// The command parameter to return
    type Parameter;

    /// Command
    const COMMAND: opcodes::HCICommand;

    fn get_parameter(&self) -> Self::Parameter;
}

/// This is a wrapper around the os HCI object
#[derive(Clone,Debug)]
pub struct HostInterface {
    #[cfg(unix)]
    interface: unix::HCIAdapter,
}

/// Error type for hci commands/events
#[derive(Debug,PartialEq,Clone)]
pub enum CommandError<SysErr,SpecErr>
    where SysErr  : Display + Debug + Clone ,
          SpecErr : Display + Debug + Clone
{
    /// System specific error
    SystemError(SysErr),
    /// An error generated by the bluetooth device. The value is the status returned by the
    /// device to indicate the error. These errors are defined in the specification (v5 volume 2,
    /// part D section 2)
    HCI(error::Error),
    /// An error that is specifically related to the command
    Specific(SpecErr),
}

impl<SysErr, SpecErr> Display for CommandError<SysErr, SpecErr>
where SysErr  : Display + Debug + Clone,
      SpecErr : Display + Debug + Clone
{
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            CommandError::SystemError(reason) => {
                write!(f, "{}", reason)
            }
            CommandError::HCI(reason) => {
                write!(f, "{}", reason)
            }
            CommandError::Specific(reason) => {
                write!(f, "{}", reason)
            }
        }
    }
}

impl HostInterface {

    /// Send a command to the controller
    ///
    /// The command data will be used in the command packet to determine what HCI command is sent
    /// to the controller. The events specified should be the events directly returned by the
    /// controller in response to the command, they should not be events that will come later as
    /// a timeout may occur before the event is sent from the controller.
    ///
    /// A future is returned for waiting on the specified events from the controller.
    fn send_command<CmdData>(
        &self, cmd_data: CmdData,
        event: events::Events,
        timeout: Duration
    ) -> Result< impl Future<Output=Result<events::EventsData, impl Display + Debug>>, CommandError<impl Display + Debug + Clone, impl Display + Debug + Clone>>
        where CmdData: CommandParameters,
    {
        self.interface.send_command(cmd_data, event, timeout ).or_else(|e| { Err(CommandError::from(e)) })
    }

    /// Specify an event to wait for
    ///
    /// This will return a future for waiting on an events from the controller. A timeout is needed
    /// to specify how long to wait for for the event.
    ///
    /// This should be used for any events that are not directly caused by sending a command from
    /// the host to the controller. Events like CommandStatus and CommandComplete are handled by
    /// the future returned when sending a command to the controller. However later events that are
    /// not directly the result of a command from the host should be waited on by using this method.
    /// No error will return (except for an eventual timeout) if an event
    ///
    /// ```rust
    /// # use bo_tie::hci::HostInterface;
    /// # use bo_tie::hci::le::transmitter::{set_advertising_parameters, set_advertising_enable};
    /// let host_interface = HostInterface::default();
    ///
    /// // This will set advertising to be connectable and scannable undirected advertising
    /// let adv_prams = set_advertising_parameters::AdvertisingParameters::default();
    ///
    /// // The future returned by the send method is actually waiting on the CommandComplete event.
    /// await!(set_advertising_parameters::send(&host_interface, adv_prams).unwrap()).unwrap();
    ///
    /// // Again, the CommandComplete event is what the returned future is waiting on, but the
    /// // LEConnectionComplete event is not handled handled here.
    /// await!(set_advertising_enable::send(&host_interface, true).unwrap()).unwrap();
    ///
    /// // To have a future handle this event, wait_for_event must be called for the
    pub fn wait_for_event(&self, events: events::Events, timeout: Duration)
    -> Result< impl Future<Output=Result<events::EventsData, impl Display + Debug>>, CommandError<impl Display + Debug + Clone, impl Display + Debug + Clone>>
    {
        self.interface.wait_for_event(events, timeout).or_else(|e| { Err(CommandError::from(e)) })
    }
}

impl ::core::default::Default for HostInterface {

    #[cfg(unix)]
    fn default() -> Self {
        HostInterface { interface: unix::HCIAdapter::default() }
    }
}

/// For commands that only return a status
macro_rules! impl_status_return {
    ($command:expr) => {
        pub struct Return;

        impl Return {
            fn try_from( raw: u8 ) -> Result<(), error::Error> {
                let status = error::Error::from(raw);

                if let error::Error::NoError = status {
                    Ok(())
                }
                else {
                    Err(status)
                }
            }
        }

        impl_get_data_for_command!($command, u8, Return, (), error::Error);

        impl_command_data_future!(Return, (), error::Error);
    }
}

trait DisplayAndDebug: Display + Debug {}
impl<T: Display + Debug> DisplayAndDebug for T {}

#[derive(Debug)]
enum OutputErr<SendErr, ResponseErr, CmDErr>
where SendErr: Display + Debug,
      ResponseErr: Display + Debug,
      CmDErr: Display + Debug,
{
    CommandSendErr(SendErr),
    EventResponseError(ResponseErr),
    /// The first item is the received event and the second item is the event expected
    ReceivedIncorrectEvent(crate::hci::events::Events, crate::hci::events::Events),
    CommandDataConversionError(CmDErr),
    /// This is used when either the 'command complete' or 'command status' events contain no data
    /// and are used to indicate the maximum number of HCI command packets that can be queued by
    /// the controller.
    ResponseHasNoAssociatedCommand,
    CommandStatusErr(error::Error),
}

impl<SendErr, ResponseErr, CmDErr> Display for OutputErr<SendErr, ResponseErr, CmDErr>
where SendErr: Display + Debug,
      ResponseErr: Display + Debug,
      CmDErr: Display + Debug,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            OutputErr::CommandSendErr(reason) => {
                core::write!(f, "Error occured when trying to send HCI command, {}", reason)
            },
            OutputErr::EventResponseError(reason) => {
                core::write!(f, "Error occured with expected HCI event in response to command, {}",
                    reason)
            },
            OutputErr::ReceivedIncorrectEvent(received_event, expected_event) => {
                core::write!(f, "Received unexpected event '{:?}' from the bluetooth controller, \
                    expected event {:?}", received_event, expected_event )
            },
            OutputErr::CommandDataConversionError(reason) => {
                core::write!(f, "{}", reason)
            },
            OutputErr::ResponseHasNoAssociatedCommand => {
                core::write!(f,"Event Response contains no data and is not associated with \
                    a HCI command. This should have been handled by the driver and not received \
                    here")
            },
            OutputErr::CommandStatusErr(reason) => {
                core::write!(f, "{}", reason)
            }
        }
    }
}

#[cfg(not(test))]
macro_rules! event_pattern_creator {
    ( $event_path:path, $( $data:pat ),+ ) => { $event_path ( $($data),+ ) };
    ( $event_path:path ) => { $event_path };
}

#[cfg(test)]
macro_rules! event_pattern_creator {
    ( $event_path:path, $( $data:pat ),+ ) => { $event_path ( $($data,)+ _) };
    ( $event_path:path ) => { $event_path(_) };
}

macro_rules! impl_returned_future {
    // these inputs match the inputs from crate::hci::events::impl_get_data_for_command
    ($return_type: ty, $event: path, $data:pat, $error:ty, $to_do: block) => {

        struct ReturnedFuture<T,SE,RE>( Result<T, SE> )
        where SE: core::fmt::Display + core::fmt::Debug + core::marker::Unpin + core::clone::Clone,
              RE: core::fmt::Display + core::fmt::Debug,
              T: Future<Output = Result<crate::hci::events::EventsData, RE>> + Unpin;

        impl<T,SE,RE> core::future::Future for ReturnedFuture<T,SE,RE>
        where SE: core::fmt::Display + core::fmt::Debug + core::marker::Unpin + core::clone::Clone,
              RE: core::fmt::Display + core::fmt::Debug,
              T:  Future<Output = core::result::Result<crate::hci::events::EventsData, RE>>
                  + core::marker::Unpin
        {
            type Output = core::result::Result< $return_type, crate::hci::OutputErr<SE,RE,$error>>;

            fn poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::Context) -> core::task::Poll<Self::Output> {
                match &mut self.get_mut().0 {
                    Ok(future) => {
                        if let core::task::Poll::Ready(result) = core::pin::Pin::new(future).poll(cx) {
                            match result {
                                Ok( event_pattern_creator!($event, $data) ) => $to_do,
                                Ok(event @ _) => {
                                    let expected_event = crate::hci::events::Events::CommandComplete;
                                    let received_event = event.get_enum_name();

                                    let ret = Err(crate::hci::OutputErr::ReceivedIncorrectEvent(expected_event, received_event));

                                    core::task::Poll::Ready(ret)
                                },
                                Err(reason) =>
                                    core::task::Poll::Ready(Err(crate::hci::OutputErr::EventResponseError(reason))),
                            }
                        } else {
                            core::task::Poll::Pending
                        }
                    },
                    Err(reason) => core::task::Poll::Ready(Err(crate::hci::OutputErr::CommandSendErr(reason.clone())))
                }
            }
        }
    };

}

macro_rules! impl_command_data_future {
    ($data_type: ty, $return_type: ty, $try_from_err_ty:ty) => {
        impl_returned_future!(
            $return_type,
            crate::hci::events::EventsData::CommandComplete,
            data,
            crate::hci::events::CommandDataErr<$try_from_err_ty>,
            {
                use crate::hci::OutputErr::{
                    ResponseHasNoAssociatedCommand,
                    CommandDataConversionError
                };

                match unsafe {
                    (&data as &crate::hci::events::GetDataForCommand<$data_type>)
                        .get_return()
                } {
                    Ok(Some(ret_val)) => core::task::Poll::Ready(Ok(ret_val)),
                    Ok(None) =>
                        core::task::Poll::Ready(Err(ResponseHasNoAssociatedCommand)),
                    Err(reason) =>
                        core::task::Poll::Ready(Err(CommandDataConversionError(reason))),
                }
            }
        );
    };
    ($data: ty, $try_from_err_ty:ty) => { impl_command_data_future!($data, $data, $try_from_err_ty); };
}

macro_rules! impl_command_status_future {
    () => {
        impl_returned_future!{
            (),
            crate::hci::events::EventsData::CommandStatus,
            data,
            &'static str,
            {
                use crate::hci::OutputErr::CommandStatusErr;

                if let crate::hci::error::Error::NoError = data.status {
                    core::task::Poll::Ready(Ok(()))
                } else {
                    core::task::Poll::Ready(Err(CommandStatusErr(data.status)))
                }
            }
        }
    };
}

#[cfg(test)]
#[macro_use]
mod test_util {

    use std::future::Future;
    use std::sync::{Arc,Mutex};

    lazy_static::lazy_static! {

        pub static ref TEST_EXCLUSION: Arc<Mutex<()>> = Arc::new(Mutex::new(()));
    }

    /// Wrapper around whatever is the future executor du jour
    #[inline]
    pub fn block_for_result<T>( future: impl Future <Output=T> ) -> T
    {
        futures::executor::block_on(future)
    }
}

pub mod le {

    #[macro_use]
    pub mod common {

        use core::convert::From;
        use core::time::Duration;

        /// The valid address types for this HCI command
        ///
        /// - PublicDeviceAddress
        ///     A bluetooth public address
        /// - RandomDeviceAddress
        ///     A bluetooth random address
        /// - DevicesSendingAnonymousAdvertisements
        ///     A device sending advertisment packets without an address
        pub enum AddressType {
            PublicDeviceAddress,
            RandomDeviceAddress,
            #[cfg(bluetooth_5_0)] DevicesSendingAnonymousAdvertisements,
        }

        impl AddressType {
            pub fn to_value(&self) -> u8 {
                match *self {
                    AddressType::PublicDeviceAddress => 0x00u8,
                    AddressType::RandomDeviceAddress => 0x01u8,
                    #[cfg(bluetooth_5_0)]
                    AddressType::DevicesSendingAnonymousAdvertisements => 0xFFu8,
                }
            }
        }

        /// Own Address Type
        ///
        /// Default is a Public Address.
        ///
        /// # Notes
        /// These are the full explanation for the last two enumerations (as copied from
        /// the core 5.0 specification):
        /// - RPAFromLocalIRKPA -> Controller generates Resolvable Private Address based on
        ///     the local IRK from the resolving list. If the resolving list contains no
        ///     matching entry, use the public address.
        /// - RPAFromLocalIRKRA -> Controller generates Resolvable Private Address based on
        ///     the local IRK from the resolving list. If the resolving list contains no
        ///     matching entry, use the random address from LE_Set_Random_Address.
        #[cfg_attr(test,derive(Debug))]
        pub enum OwnAddressType {
            PublicDeviceAddress,
            RandomDeviceAddress,
            RPAFromLocalIRKPA,
            RPAFromLocalIRKRA,
        }

        impl OwnAddressType {
            pub(super) fn into_val(&self) -> u8 {
                match *self {
                    OwnAddressType::PublicDeviceAddress => 0x00,
                    OwnAddressType::RandomDeviceAddress => 0x01,
                    OwnAddressType::RPAFromLocalIRKPA => 0x02,
                    OwnAddressType::RPAFromLocalIRKRA => 0x03,
                }
            }
        }

        impl Default for OwnAddressType {
            fn default() -> Self {
                OwnAddressType::PublicDeviceAddress
            }
        }

        #[cfg_attr(test,derive(Debug))]
        pub struct Frequency {
            val: u8
        }

        impl Frequency {
            /// Maximum frequency value
            pub const MAX: usize = 2480;

            /// Minimum frequency value
            pub const MIN: usize = 2402;

            /// Creates a new Frequency object
            ///
            /// The value (N) passed to the adapter follows the following equation:
            ///
            /// # Error
            /// The value is less then MIN or greater than MAX. MIN or MAX is returned
            /// depending on which bound is violated.
            pub fn new( mega_hz: usize ) -> Result<Frequency, usize> {
                if mega_hz < Frequency::MIN {
                    Err(Frequency::MIN)
                }
                else if mega_hz > Frequency::MAX {
                    Err(Frequency::MAX)
                }
                else {
                    Ok(Frequency{ val: ((mega_hz - 2402) / 2) as u8})
                }
            }

            pub(in super::super) fn get_val(&self) -> u8 { self.val }
        }

        pub struct IntervalRange<T> where T: PartialEq + PartialOrd {
            pub low: T,
            pub hi: T,
            pub micro_sec_conv: u64,
        }

        impl<T> IntervalRange<T> where T: PartialEq + PartialOrd {

            pub fn contains(&self, val: &T ) -> bool {
                self.low <= *val && *val <= self.hi
            }
        }

        impl From<IntervalRange<u16>> for IntervalRange<Duration> {
            fn from( raw: IntervalRange<u16> ) -> Self {
                IntervalRange {
                    low: Duration::from_micros( raw.low as u64 * raw.micro_sec_conv  ),
                    hi:  Duration::from_micros( raw.hi as u64 * raw.micro_sec_conv  ),
                    micro_sec_conv: raw.micro_sec_conv,
                }
            }
        }

        macro_rules! interval {
            ( $(#[ $expl:meta ])* $name:ident, $raw_low:expr, $raw_hi:expr,
                SpecDef, $raw_default:expr, $micro_sec_conv:expr ) =>
            {
                make_interval!(
                    $(#[ $expl ])*
                    $name,
                    $raw_low,
                    $raw_hi,
                    #[doc("This is a Bluetooth Specification defined default value")],
                    $raw_default,
                    $micro_sec_conv
                );
            };
            ( $(#[ $expl:meta ])* $name:ident, $raw_low:expr, $raw_hi:expr,
                ApiDef, $raw_default:expr, $micro_sec_conv:expr ) =>
            {
                make_interval!(
                    $(#[ $expl ])*
                    $name,
                    $raw_low,
                    $raw_hi,
                    #[doc("This is a default value defined by the API, the Bluetooth Specification")]
                    #[doc("does not specify a default for this interval")],
                    $raw_default,
                    $micro_sec_conv
                );
            }
        }

        macro_rules! make_interval {
            ( $(#[ $expl:meta ])*
                $name:ident,
                $raw_low:expr,
                $raw_hi:expr,
                $(#[ $raw_default_note:meta ])*,
                $raw_default:expr,
                $micro_sec_conv:expr) =>
            {
                $(#[ $expl ])*
                #[cfg_attr(test,derive(Debug))]
                pub struct $name {
                    interval: u16,
                }

                impl $name {

                    const RAW_RANGE: crate::hci::le::common::IntervalRange<u16> = crate::hci::le::common::IntervalRange{
                        low: $raw_low,
                        hi: $raw_hi,
                        micro_sec_conv: $micro_sec_conv,
                    };

                    /// Create an interval from a raw value
                    ///
                    /// # Error
                    /// The value is out of bounds.
                    pub fn try_from_raw( raw: u16 ) -> Result<Self, &'static str> {
                        if $name::RAW_RANGE.contains(&raw) {
                            Ok($name{
                                interval: raw,
                            })
                        }
                        else {
                            Err(concat!("Raw value out of range: ", $raw_low, "..=", $raw_hi))
                        }
                    }

                    /// Create an advertising interval from a Duration
                    ///
                    /// # Error
                    /// the value is out of bounds.
                    pub fn try_from_duration( duration: ::core::time::Duration ) -> Result<Self, &'static str>
                    {
                        let duration_range = crate::hci::le::common::IntervalRange::<::core::time::Duration>::from($name::RAW_RANGE);

                        if duration_range.contains(&duration) {
                            Ok( $name {
                                interval: (duration.as_secs() * (1000000 / $micro_sec_conv)) as u16 +
                                    (duration.subsec_micros() / $micro_sec_conv as u32) as u16,
                            })
                        }
                        else {
                            Err(concat!("Duration out of range: ",
                                stringify!( ($raw_low * $micro_sec_conv) ),
                                "us..=",
                                stringify!( ($raw_hi * $micro_sec_conv) ),
                                "us"))
                        }
                    }

                    /// Get the raw value of the interval
                    pub fn get_raw_val(&self) -> u16 { self.interval }

                    /// Get the value of the interval as a `Duration`
                    pub fn get_duration(&self) -> ::core::time::Duration {
                        ::core::time::Duration::from_micros(
                            (self.interval as u64) * $micro_sec_conv
                        )
                    }
                }

                impl Default for $name {

                    /// Creates an Interval with the default value for the interval
                    ///
                    $(#[ $raw_default_note ])*
                    fn default() -> Self {
                        $name{
                            interval: $raw_default,
                        }
                    }
                }
            };
        }
    }

    /// Manditory commands for a device that implements lE
    ///
    /// Some of these functions are not specific to Bluetooth LE, but they are here to be noted
    /// that they are associated with LE.
    ///
    /// Vol2 Part E 3.1 of the Bluetooth spec
    pub mod mandatory {

        macro_rules! add_remove_white_list_setup {
            ( $command: ident ) => {
                use crate::hci::*;
                use crate::hci::events::Events;
                use crate::hci::le::common::AddressType;

                /// Command parameter data for both add and remove whitelist commands.
                ///
                /// Not using bluez becasue there are different parameter structs for the
                /// two commands even though they are the same in structure.
                #[repr(packed)]
                #[derive(Clone, Copy)]
                struct CommandPrameter {
                    _address_type: u8,
                    _address: [u8;6],
                }

                impl_status_return!( $command );

                pub fn send( hci: &HostInterface,
                    at: AddressType,
                    addr: crate::BluetoothDeviceAddress )
                -> impl core::future::Future<Output=Result<(), impl Display + Debug>>
                {
                    let parameter = CommandPrameter {
                        _address_type: at.to_value(),
                        _address: addr,
                    };

                    ReturnedFuture( hci.send_command(parameter, Events::CommandComplete, Duration::from_secs(1) ) )
                }

                impl CommandParameters for CommandPrameter {
                    type Parameter = Self;
                    const COMMAND: opcodes::HCICommand = $command;
                    fn get_parameter(&self) -> Self::Parameter { *self }
                }
            };
        }
        pub mod add_device_to_white_list {
            const COMMAND: crate::hci::opcodes::HCICommand = crate::hci::opcodes::HCICommand::LEController(crate::hci::opcodes::LEController::AddDeviceToWhiteList);

            add_remove_white_list_setup!(COMMAND);

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::process::Command;
                use crate::BluetoothDeviceAddress;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn add_device_to_white_list_test() {
                    let _u = crate::hci::test_util::TEST_EXCLUSION.lock().unwrap();

                    let test_address_1 = BluetoothDeviceAddress::from([0x11,0x22,0x33,0x44,0x55,0x66]);
                    let test_address_2 = BluetoothDeviceAddress::from([0x12,0x34,0x56,0x78,0x9A,0xBC]);

                    let test_address_1_str = format!("{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                        test_address_1[5],
                        test_address_1[4],
                        test_address_1[3],
                        test_address_1[2],
                        test_address_1[1],
                        test_address_1[0]
                    );

                    let test_address_2_str = format!("{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                        test_address_2[5],
                        test_address_2[4],
                        test_address_2[3],
                        test_address_2[2],
                        test_address_2[1],
                        test_address_2[0],
                    );

                    let adapter = HostInterface::default();

                    block_for_result( send(&adapter, AddressType::PublicDeviceAddress, test_address_1))
                        .unwrap();

                    Command::new("hcitool")
                        .args(&["lewlrm", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    block_for_result(send(&adapter, AddressType::RandomDeviceAddress, test_address_2))
                        .unwrap();

                    Command::new("hcitool")
                        .args(&["lewlrm", &test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    #[cfg(bluetooth_5_0)]
                    {
                        let result = block_for_result(
                            send(&adapter, AddressType::DevicesSendingAnonymousAdvertisements, [0;6])
                        ).unwrap();

                        assert_eq!(1, result.len() );

                    }
                }
            }
        }
        pub mod clear_white_list {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ClearWhiteList);

            #[derive(Clone, Copy)]
            struct Prameter;

            impl CommandParameters for Prameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_status_return!(COMMAND);

            pub fn send( hci: &HostInterface ) -> impl Future<Output=Result<(), impl Display + Debug>> {
                ReturnedFuture( hci.send_command(Prameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;
                use std::process::Command;

                #[test]
                pub fn clear_white_list_test() {

                    let _u = crate::hci::test_util::TEST_EXCLUSION.lock().unwrap();

                    let test_address_1 = crate::BluetoothDeviceAddress::from([0x11,0x22,0x33,0x44,0x55,0x66]);
                    let test_address_2 = crate::BluetoothDeviceAddress::from([0x12,0x34,0x45,0x56,0x78,0x8A]);

                    let test_address_1_str = format!("{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                        test_address_1[5],
                        test_address_1[4],
                        test_address_1[3],
                        test_address_1[2],
                        test_address_1[1],
                        test_address_1[0],
                    );
                    let test_address_2_str =format!("{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                        test_address_2[5],
                        test_address_2[4],
                        test_address_2[3],
                        test_address_2[2],
                        test_address_2[1],
                        test_address_2[0],
                    );

                    let host_interface = HostInterface::default();

                    Command::new("hcitool")
                        .args(&["lewladd", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    Command::new("hcitool")
                        .args(&["lewladd", &test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    block_for_result(send(&host_interface)).unwrap();

                    let output_1 = Command::new("hcitool")
                        .args(&["lewlrm", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    let output_2 = Command::new("hcitool")
                        .args(&["lewlrm", &*test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    assert!( !output_1.status.success(), "hcitool should not have succeded");
                    assert!( !output_2.status.success(), "hcitool should not have succeded");
                }
            }
        }
        pub mod read_buffer_size {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReadBufferSize);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                packet_length: u16,
                maximum_packet_cnt: u8,
            }

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            /// This type consists of the ACL packet data length and total number of ACL data
            /// packets the Bluetooth device (controller portion) can store.
            ///
            /// If either member of BufferSize is None (they are either both None or both Some),
            /// then the Read Buffer Size (v5 | vol2, part E, sec 7.4.5) command should be used
            /// instead.
            #[derive(Debug)]
            pub struct BufferSize {
                /// The maximum size of each packet
                pub packet_len: Option<u16>,
                /// The maximum number of packets that the controller can hold
                pub packet_cnt: Option<u8>,
            }

            impl BufferSize {
                fn try_from(packed: CmdReturn) -> Result<Self, error::Error >{
                    let err_val = error::Error::from(packed.status);

                    match err_val {
                        error::Error::NoError => {
                            let len = if packed.packet_length != 0 {
                                Some(packed.packet_length)
                            } else {
                                None
                            };

                            let cnt = if packed.maximum_packet_cnt != 0 {
                                Some(packed.maximum_packet_cnt)
                            } else {
                                None
                            };

                            Ok(BufferSize {
                                packet_len: len,
                                packet_cnt: cnt,
                            })
                        },
                        _ => Err(err_val),
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                BufferSize,
                error::Error);

            impl_command_data_future!(BufferSize, error::Error);

            pub fn send( hci: &HostInterface ) -> impl Future<Output=Result<BufferSize,impl Display + Debug>> {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn read_buffer_size_test() {

                    block_for_result(send(&HostInterface::default())).unwrap();

                }
            }
        }
        pub mod read_local_supported_features {

            use crate::hci::common::EnabledLEFeaturesItr;
            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReadLocalSupportedFeatures);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                features: [u8;8]
            }

            impl EnabledLEFeaturesItr {
                fn try_from( packed: CmdReturn ) -> Result<Self,error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(EnabledLEFeaturesItr::from(packed.features))
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                EnabledLEFeaturesItr,
                error::Error
            );

            impl_command_data_future!(EnabledLEFeaturesItr, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<EnabledLEFeaturesItr, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn read_local_supported_features_test() {

                    block_for_result(send(&HostInterface::default())).unwrap();

                }
            }
        }
        pub mod read_supported_states {

            use crate::hci::*;
            use alloc::collections::BTreeSet;
            use alloc::vec::Vec;
            use core::mem::size_of_val;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReadSupportedStates);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                states: [u8;8],
            }

            /// All possible states/roles a controller can be in
            #[derive(PartialEq,Eq,PartialOrd,Ord,Debug)]
            pub enum StatesAndRoles {
                ScannableAdvertisingState,
                ConnectableAdvertisingState,
                NonConnectableAdvertisingState,
                HighDutyCyleDirectedAdvertisingState,
                LowDutyCycleDirectedAdvertisingState,
                ActiveScanningState,
                PassiveScanningState,
                InitiatingState,
                ConnectionStateMasterRole,
                ConnectionStateSlaveRole
            }

            impl StatesAndRoles {

                /// Returns the total number of states and roles
                fn get_count() -> usize { 10 }

                /// Returns the total possible bit options
                ///
                /// See Bluetooth v5 vol 2 part E 7.8.27
                fn get_bit_count() -> usize { 41 }

                /// This function doesn't return all available states and roles of a device
                /// (since devices can set multiple of these bits indicating the available
                /// roles) so it doesn't return the special type name.
                fn get_states_for_bit_val( bit_val: usize) -> Vec<Self> {
                    use self::StatesAndRoles::*;

                    match bit_val {
                        0  => vec![ NonConnectableAdvertisingState],
                        1  => vec![ ScannableAdvertisingState],
                        2  => vec![ ConnectableAdvertisingState],
                        3  => vec![ HighDutyCyleDirectedAdvertisingState],
                        4  => vec![ PassiveScanningState],
                        5  => vec![ ActiveScanningState],
                        6  => vec![ InitiatingState],
                        7  => vec![ ConnectionStateSlaveRole],
                        8  => vec![ NonConnectableAdvertisingState,
                                    PassiveScanningState],
                        9  => vec![ ScannableAdvertisingState,
                                    PassiveScanningState],
                        10 => vec![ ConnectableAdvertisingState,
                                    PassiveScanningState],
                        11 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    PassiveScanningState],
                        12 => vec![ NonConnectableAdvertisingState,
                                    ActiveScanningState],
                        13 => vec![ ScannableAdvertisingState,
                                    ActiveScanningState],
                        14 => vec![ ConnectableAdvertisingState,
                                    ActiveScanningState],
                        15 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    ActiveScanningState],
                        16 => vec![ NonConnectableAdvertisingState,
                                    InitiatingState],
                        17 => vec![ ScannableAdvertisingState,
                                    InitiatingState],
                        18 => vec![ NonConnectableAdvertisingState,
                                    ConnectionStateMasterRole],
                        19 => vec![ ScannableAdvertisingState,
                                    ConnectionStateMasterRole],
                        20 => vec![ NonConnectableAdvertisingState,
                                    ConnectionStateSlaveRole],
                        21 => vec![ ScannableAdvertisingState,
                                    ConnectionStateSlaveRole],
                        22 => vec![ PassiveScanningState,
                                    InitiatingState],
                        23 => vec![ ActiveScanningState,
                                    InitiatingState],
                        24 => vec![ PassiveScanningState,
                                    ConnectionStateMasterRole],
                        25 => vec![ ActiveScanningState,
                                    ConnectionStateMasterRole],
                        26 => vec![ PassiveScanningState,
                                    ConnectionStateSlaveRole],
                        27 => vec![ ActiveScanningState,
                                    ConnectionStateSlaveRole],
                        28 => vec![ InitiatingState,
                                    ConnectionStateMasterRole],
                        29 => vec![ LowDutyCycleDirectedAdvertisingState ],
                        30 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    PassiveScanningState],
                        31 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    ActiveScanningState],
                        32 => vec![ ConnectableAdvertisingState,
                                    InitiatingState],
                        33 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    InitiatingState],
                        34 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    InitiatingState],
                        35 => vec![ ConnectableAdvertisingState,
                                    ConnectionStateMasterRole],
                        36 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    ConnectionStateMasterRole],
                        37 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    ConnectionStateMasterRole],
                        38 => vec![ ConnectableAdvertisingState,
                                    ConnectionStateSlaveRole],
                        39 => vec![ HighDutyCyleDirectedAdvertisingState,
                                    ConnectionStateSlaveRole],
                        40 => vec![ LowDutyCycleDirectedAdvertisingState,
                                    ConnectionStateSlaveRole],
                        41 => vec![ InitiatingState,
                                    ConnectionStateSlaveRole],
                        _  => vec![],
                    }
                }

                fn collect_to_vec( bts: BTreeSet<StatesAndRoles> ) -> Vec<Self> {
                    let mut retval = Vec::<Self>::with_capacity(
                        StatesAndRoles::get_count()
                    );

                    for state_or_role in bts {
                        retval.push(state_or_role)
                    }

                    retval
                }

                /// This function will return all the supported states
                fn get_supported_states( rss: &CmdReturn) -> Vec<Self> {

                    let mut set = BTreeSet::new();

                    let count = StatesAndRoles::get_bit_count();

                    for byte in 0..size_of_val(&rss.states) {
                        for bit in 0..8 {
                            if (byte * 8 + bit) < count {
                                if 0 != rss.states[byte] & ( 1 << bit ) {
                                    for state_or_role in StatesAndRoles::get_states_for_bit_val( bit ) {
                                        set.insert(state_or_role);
                                    }
                                }
                            }
                            else {
                                return StatesAndRoles::collect_to_vec(set);
                            }
                        }
                    }
                    StatesAndRoles::collect_to_vec(set)
                }

                fn try_from(packed: CmdReturn) -> Result<Vec<Self>, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(StatesAndRoles::get_supported_states(&packed))
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                StatesAndRoles,
                Vec<StatesAndRoles>,
                error::Error
            );

            impl_command_data_future!(StatesAndRoles, Vec<StatesAndRoles>, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<Vec<StatesAndRoles>, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn read_supported_states_test() {

                    block_for_result(send(&HostInterface::default())).unwrap();

                }
            }
        }
        pub mod read_white_list_size {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReadWhiteListSize);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                size: u8,
            }

            pub struct Return;

            impl Return {
                fn try_from( packed: CmdReturn) -> Result<usize, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(packed.size as usize)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command! (
                COMMAND,
                CmdReturn,
                Return,
                usize,
                error::Error
            );

            impl_command_data_future!(Return, usize, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<usize, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::process::Command;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn read_white_list_size_test() {

                    let output = Command::new("hcitool")
                        .arg("lewlsz")
                        .output()
                        .expect("failed to execute process");

                    let hcitool_cnt = String::from_utf8_lossy(&output.stdout)
                            .trim_start_matches("White list size: ")
                            .trim_end()
                            .parse::<usize>()
                            .expect("Couldn't convert string to number");

                    let hci_result = block_for_result(send(&HostInterface::default())).unwrap();

                    assert_eq!(hcitool_cnt, hci_result);
                }
            }
        }
        pub mod remove_device_from_white_list {

            const COMMAND: crate::hci::opcodes::HCICommand = crate::hci::opcodes::HCICommand::LEController(crate::hci::opcodes::LEController::RemoveDeviceFromWhiteList);

            add_remove_white_list_setup!(COMMAND);

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;
                use std::process::Command;

                #[test]
                fn remove_device_from_white_list_test() {

                    let _u = crate::hci::test_util::TEST_EXCLUSION.lock().unwrap();

                    let test_address_1 = crate::BluetoothDeviceAddress::from([0x11,0x22,0x33,0x44,0x55,0x66]);
                    let test_address_2 = crate::BluetoothDeviceAddress::from([0x12,0x34,0x45,0x56,0x78,0x8A]);
                    let test_address_3 = crate::BluetoothDeviceAddress::from([0xff,0xee,0xdd,0xcc,0xbb,0xaa]);

                    let test_address_1_str = format!("{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                        test_address_1[5],
                        test_address_1[4],
                        test_address_1[3],
                        test_address_1[2],
                        test_address_1[1],
                        test_address_1[0],
                    );
                    let test_address_2_str = format!("{:02X}:{:02X}:{:02X}:{:02X}:{:02X}:{:02X}",
                        test_address_2[5],
                        test_address_2[4],
                        test_address_2[3],
                        test_address_2[2],
                        test_address_2[1],
                        test_address_2[0],
                    );

                    let hi = HostInterface::default();

                    Command::new("hcitool")
                        .args(&["lewladd", &test_address_1_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    Command::new("hcitool")
                        .args(&["lewladd", "--random", &test_address_2_str])
                        .output()
                        .expect("Failed to execute hcitool command");

                    block_for_result(
                        send(&hi, AddressType::PublicDeviceAddress, test_address_1)
                    )
                    .unwrap();

                    block_for_result(
                        send(&hi, AddressType::RandomDeviceAddress, test_address_2)
                    )
                    .unwrap();

                    block_for_result(
                        send(&hi, AddressType::PublicDeviceAddress, test_address_3)
                    )
                    .unwrap_err();
                }
            }
        }
        pub mod set_event_mask {

            use crate::hci::*;
            use alloc::vec::Vec;
            use crate::hci::events::LEMeta;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetEventMask);

            impl LEMeta {

                fn bit_offset(&self) -> usize{
                    match *self {
                        LEMeta::ConnectionComplete => 0,
                        LEMeta::AdvertisingReport => 1,
                        LEMeta::ConnectionUpdateComplete => 2,
                        LEMeta::ReadRemoteFeaturesComplete => 3,
                        LEMeta::LongTermKeyRequest => 4,
                        LEMeta::RemoteConnectionParameterRequest => 5,
                        LEMeta::DataLengthChange => 6,
                        LEMeta::ReadLocalP256PublicKeyComplete => 7,
                        LEMeta::GenerateDHKeyComplete => 8,
                        LEMeta::EnhancedConnectionComplete => 9,
                        LEMeta::DirectedAdvertisingReport => 10,
                        LEMeta::PHYUpdateComplete => 11,
                        LEMeta::ExtendedAdvertisingReport => 12,
                        LEMeta::PeriodicAdvertisingSyncEstablished => 13,
                        LEMeta::PeriodicAdvertisingReport => 14,
                        LEMeta::PeriodicAdvertisingSyncLost => 15,
                        LEMeta::ScanTimeout => 16,
                        LEMeta::AdvertisingSetTerminated => 17,
                        LEMeta::ScanRequestReceived => 18,
                        LEMeta::ChannelSelectionAlgorithm => 19,
                    }
                }

                fn build_mask( events: Vec<Self>) -> [u8;8] {
                    let mut mask = <[u8;8]>::default();

                    for event in events {
                        let bit = event.bit_offset();
                        let byte = bit/8;

                        mask[byte] |= 1 << (bit % 8);
                    }

                    mask
                }
            }

            impl_status_return!(COMMAND);

            #[repr(packed)]
            #[derive( Clone, Copy)]
            struct CmdParameter {
                _mask: [u8;8]
            }

            impl CommandParameters for CmdParameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            /// Set the enabled events on a device
            ///
            /// ```rust
            /// # use bo_tie_linux::hci::le::mandatory::set_event_mask::*;
            /// # let host_interface = bo_tie_linux::hci::HostInterface::default();
            ///
            /// let events = vec!(Events::LEConnectionComplete,Events::LEAdvertisingReport);
            ///
            /// // This will enable the LE Connection Complete Event and LE Advertising Report Event
            /// send(&host_interface, events);
            /// ```
            pub fn send( hi: &HostInterface, enabled_events: Vec<LEMeta>)
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {

                let command_pram = CmdParameter {
                    _mask: LEMeta::build_mask(enabled_events),
                };

                ReturnedFuture( hi.send_command(command_pram, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;
                use crate::hci::events::LEMeta;

                #[test]
                fn set_event_mask_test() {

                    let hi = HostInterface::default();

                    let enabled_events = vec! [
                        LEMeta::ConnectionComplete,
                        LEMeta::AdvertisingReport,
                        LEMeta::ConnectionUpdateComplete,
                        LEMeta::ReadRemoteFeaturesComplete,
                    ];

                    block_for_result(send( &hi, enabled_events )).unwrap();
                }
            }
        }
        pub mod test_end {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::TestEnd);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                number_of_packets: u16
            }

            pub struct Return;

            impl Return {
                fn try_from(packed: CmdReturn) -> Result<usize, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(packed.number_of_packets as usize)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                Return,
                usize,
                error::Error
            );

            impl_command_data_future!(Return, usize, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            /// This will return a future with its type 'Output' being the number of packets
            /// received during what ever test was done
            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<usize, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                #[should_panic]
                fn test_end_test() {

                    block_for_result(send( &HostInterface::default() )).unwrap();

                }
            }
        }
        /// This is part of the Informational Parameters opcodesgroup
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_bd_addr {

            use crate::BluetoothDeviceAddress;
            use crate::hci::*;
            use core::fmt::{Display, Debug};

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::InformationParameters(opcodes::InformationParameters::ReadBD_ADDR);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                address: BluetoothDeviceAddress,
            }

            struct Return;

            impl Return {
                fn try_from(packed: CmdReturn) -> Result<BluetoothDeviceAddress, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(packed.address)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                Return,
                BluetoothDeviceAddress,
                error::Error
            );

            impl_command_data_future!(Return, BluetoothDeviceAddress, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            /// Returns the bluetooth device address for the device
            pub fn send( hci: &HostInterface ) -> impl Future<Output=Result<BluetoothDeviceAddress, impl Display + Debug>> {
                use events::Events::CommandComplete;

                let cmd_rslt = hci.send_command(Parameter, CommandComplete, Duration::from_secs(1) );

                ReturnedFuture(cmd_rslt)
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::process::Command;
                use std::iter::Iterator;
                use crate::hci::test_util::block_for_result;

                trait TryCollect<A> {
                    fn try_collect(self) -> Result<A,&'static str>;
                }

                impl<T> TryCollect<[u8;6]> for T where T: Iterator<Item=u8> {

                    fn try_collect(self) -> Result<[u8;6],&'static str> {
                        let mut arr = [0u8;6];

                        let mut index = 0;
                        for val in self {
                            if index < 6 {
                                arr[index] = val;
                                index += 1
                            }
                            else {
                                return Err("Device address is too large");
                            }
                        }

                        if index < 6 {
                            Err("Device address is too small")
                        }
                        else {
                            Ok(arr)
                        }
                    }
                }

                #[test]
                fn ip_read_bd_addr_test() {

                    let output = Command::new("hcitool")
                        .arg("dev")
                        .output()
                        .expect("failed to execute process");

                    let mut hcitool_bdaddr: BluetoothDeviceAddress =
                        String::from_utf8_lossy(&output.stdout)
                            .trim_start_matches(|c: char| c != '0')
                            .trim_start_matches("0")
                            .trim()
                            .split(":")
                            .map(|s| u8::from_str_radix(s,16).unwrap() )
                            .try_collect()
                            .unwrap();

                    hcitool_bdaddr.reverse();

                    block_for_result(send(&HostInterface::default())).unwrap();

                }
            }
        }
        /// This is part of the Informational Parameters opcodesgroup
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_local_supported_features {

            use crate::hci::*;
            use crate::hci::common::EnabledFeaturesIter;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::InformationParameters(opcodes::InformationParameters::ReadLocalSupportedFeatures);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                features: [u8;8],
            }

            impl EnabledFeaturesIter {
                fn try_from(packed: CmdReturn) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(EnabledFeaturesIter::from(packed.features))
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command! (
                COMMAND,
                CmdReturn,
                EnabledFeaturesIter,
                error::Error
            );

            impl_command_data_future!(EnabledFeaturesIter, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<EnabledFeaturesIter, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn ip_read_local_supported_features() {

                    block_for_result(send(&HostInterface::default()))
                        .unwrap();

                }
            }
        }
        // This is part of the Information Parameters opcodesgroup
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_local_version_information {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::InformationParameters(opcodes::InformationParameters::ReadLocalSupportedVersionInformation);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                hci_version: u8,
                hci_revision: u16,
                lmp_pal_version: u8,
                manufacturer_name: u16,
                lmp_pal_subversion: u16,
            }

            #[derive(Debug)]
            pub struct VersionInformation {
                pub hci_version: u8,
                pub hci_revision: u16,
                pub lmp_pal_version: u8,
                pub manufacturer_name: u16,
                pub lmp_pal_subversion: u16,
            }

            impl VersionInformation {
                fn try_from(packed: CmdReturn) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok( Self {
                            hci_version: packed.hci_version,
                            hci_revision: packed.hci_revision,
                            lmp_pal_version: packed.lmp_pal_version,
                            manufacturer_name: packed.manufacturer_name,
                            lmp_pal_subversion: packed.lmp_pal_subversion,
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                VersionInformation,
                error::Error
            );

            impl_command_data_future!(VersionInformation, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<VersionInformation, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn ip_read_local_version_information_test() {
                    block_for_result( send(&HostInterface::default()) ).unwrap();
                }
            }
        }
        // This is part of the Host Controller and Baseband opcodesgroup
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod reset {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::ControllerAndBaseband(opcodes::ControllerAndBaseband::Reset);

            impl_status_return!(COMMAND);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            pub fn send( hci: &HostInterface ) -> impl Future<Output=Result<(), impl Display + Debug>> {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn reset_test() {

                    block_for_result(send(&HostInterface::default())).unwrap();

                }
            }
        }
        // This is part of the Informational Parameters opcodesgroup
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod ip_read_local_supported_commands {

            use crate::hci::*;
            use core::option::Option;
            use alloc::vec::Vec;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::InformationParameters(opcodes::InformationParameters::ReadLocalSupportedCommands);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                supported_commands: [u8;64],
            }

            #[cfg_attr(test,derive(Debug))]
            #[derive(PartialEq)]
            pub enum SupportedCommands {
                Inquiry,
                InquiryCancel,
                PeriodicInquiryMode,
                ExitPeriodicInquiryMode,
                CreateConnection,
                Disconnect,
                /// Depreciated
                AddSCOConnection,
                CreateConnectionCancel,
                AcceptConnectionRequest,
                RejectConnectionRequest,
                LinkKeyRequestReply,
                LinkKeyRequestNegativeReply,
                PINCodeRequestReply,
                PINCodeRequestNegativeReply,
                ChangeConnectionPacketType,
                AuthenticationRequested,
                SetConnectionEncryption,
                ChangeConnectionLinkKey,
                MasterLinkKey,
                RemoteNameRequest,
                RemoteNameRequestCancel,
                ReadRemoteSupportedFeatures,
                ReadRemoteExtendedFeatures,
                ReadRemoteVersionInformation,
                ReadClockOffset,
                ReadLMPHandle,
                HoldMode,
                SniffMode,
                ExitSniffMode,
                QosSetup,
                RoleDiscovery,
                SwitchRole,
                ReadLinkPolicySettings,
                WriteLinkPolicySettings,
                ReadDefaultLinkPolicySettings,
                WriteDefaultLinkPolicySettings,
                FlowSpecification,
                SetEventMask,
                Reset,
                SetEVentFilter,
                Flush,
                ReadPINType,
                WritePINType,
                CreateNewUnitKey,
                ReadStoredLinkKey,
                WriteStoredLinkKey,
                DeleteStoredLinkKey,
                WriteLocalName,
                ReadLocalName,
                ReadConnectionAcceptedTimeout,
                WriteConnectionAcceptedTimeout,
                ReadPageTimeout,
                WritePageTimeout,
                ReadScanEnable,
                WriteScanEnable,
                ReadPageScanActivity,
                WritePageScanActivity,
                ReadInquiryScanActivity,
                WriteInquiryScanActivity,
                ReadAuthenticationEnable,
                WriteAuthenticationEnable,
                ///Depreciated
                ReadEncryptionMode,
                ///Depreciated
                WriteEncryptionMode,
                ReadClassOfDevice,
                WriteClassOfDevice,
                REadVoiceSetting,
                WriteVoiceSetting,
                ReadAutomaticFlushTimeout,
                WriteAutomaticFlushTimeout,
                ReadNumBroadcastRetransmission,
                WriteNumBroadcastRetransmissions,
                ReadHoldModeActivity,
                WriteHoldModeActiviy,
                ReadTransmitPowerLevel,
                ReadSynchronousFlowControlEnable,
                WriteSynchronousFlowControlEnable,
                SetConrollerToHostFlowControl,
                HostBufferSize,
                HostNumberOfCompletedPackets,
                ReadLinkSupervisionTimeout,
                WriteLinkSupervisionTimeout,
                ReadNumberOfSupportedIAC,
                ReadCurrentIACLAP,
                WriteCurrentIACLAP,
                /// Depreciated
                ReadPageScanModePeriod,
                /// Depreciated
                WritePageScanModePeriod,
                /// Depreciated
                ReadPageScanMode,
                /// Depreciated
                WritePageSanMode,
                SetAFHHostChannel,
                ReadInquiryScanType,
                WriteInquirySCanType,
                ReadInquiryMode,
                WriteInquiryMode,
                ReadPageScanType,
                WritePageScanType,
                ReadAFHChannelAssessmentMode,
                WriteAFHChannelAssessmentMode,
                ReadLocalVersionInformation,
                ReadLocalSupportedFeatures,
                ReadLocalExtendedFeatures,
                ReadBufferSize,
                /// Depreciated
                ReadCountryCode,
                ReadBDADDR,
                ReadFAiledContactCounter,
                ResetFailedContactCounter,
                ReadLinkQuality,
                ReadRSSI,
                ReadAFHChannelMap,
                ReadClock,
                ReadLoopbackMode,
                WriteLoopbackMode,
                EnableDeviceUnderTestMode,
                SetupSynchronousConnectionRequest,
                AcceptSynchronousConnectionRequest,
                RejectSynchronousConnectionRequest,
                ReadExtendedInquiryResponse,
                WriteExtendedInquiryResponse,
                RefreshEncryptionKey,
                SniffSubrating,
                ReadSimplePairingMode,
                WriteSimplePairingMode,
                ReadLocalOOBData,
                ReadInquiryResponseTransmitPowerLevel,
                WriteInquiryTransmitPowerLevel,
                ReadDefaultErroneousDataReporting,
                WriteDefaultErroneousDataReporting,
                IOCapabilityRequestReply,
                UserConfirmationRequestReply,
                UserConfirmationRequestNegativeReply,
                UserPasskeyRequestReply,
                UserPasskeyRequestNegativeReply,
                RemoteOOBDataRequestReply,
                WriteSimplePairingDebugMode,
                EnhancedFlush,
                RemoteOOBDataRequestNagativeReply,
                SendKeypressNotification,
                IOCapabilityRequestNegativeReply,
                ReadEncryptionKeySize,
                CreatePhysicalLink,
                AcceptPhysicalLink,
                DisconnectPhysicalLink,
                CreateLogicalLink,
                AcceptLogicalLink,
                DisconnectLogicalLink,
                LogicalLinkCancel,
                FlowSpecModify,
                ReadLogicalLinkAcceptTimeout,
                WriteLogicalLinkAcceptTimeout,
                SetEventMaskPage2,
                ReadLocationData,
                WRiteLocationData,
                ReadLocalAMPInfo,
                ReadLocalAMPASSOC,
                WriteRemoteAMPASSOC,
                READFlowControlMode,
                WriteFlowControlMode,
                ReadDataBlockSize,
                EnableAMPReceiverReports,
                AMPTestEnd,
                AmPTest,
                ReadEnhancedTransmitPowerLevel,
                ReadBestEffortFlushTimeout,
                WriteBestEffortFlushTimeout,
                ShortRangeMode,
                ReadLEHostSupport,
                WriteLEHostSupport,
                LESetEventMask,
                LEReadBufferSize,
                LEReadLocalSupportedFeatures,
                LESetRandomAddress,
                LESetAdvertisingParameters,
                LEReadAdvertisingChannelTXPower,
                LESetAdvertisingData,
                LESetScanResponseData,
                LESetAdvertisingEnable,
                LESetScanParameters,
                LESetScanEnable,
                LECreateConnection,
                LECreateConnectionCancel,
                LEReadWhiteListSize,
                LEClearWhiteList,
                LEAddDeviceToWhiteList,
                LERemoveDeviceFromWhiteList,
                LEConnectionUpdate,
                LESetHostChannelClassification,
                LEReadChannelMap,
                LEReadRemoteFeatures,
                LEEncrypt,
                LERand,
                LEStartEncryption,
                LELongTermKeyRequestReply,
                LELongTermKeyRequestNegativeReply,
                LEReadSupportedStates,
                LEReceiverTest,
                LETransmitterTest,
                LETestEnd,
                EnhancedSetupSynchronousConnection,
                EnhancedAcceptSynchronousConnection,
                ReadLocalSupportedCondecs,
                SetMWSChannelParameters,
                SetExternalFrameConfiguration,
                SetMWSSignaling,
                SetMWSTransportLayer,
                SetMWSScanFrequencyTable,
                GetMWSTransportLayerConfiguration,
                SetMWSPATTERNConfiguration,
                SetTriggeredClockCapture,
                TruncatedPage,
                TruncatedPageCancel,
                SetConnectionlessSlaveBroadcast,
                SetConnectionlessSlaveBroadcastReceive,
                StartSynchronizationTrain,
                ReceiveSynchronizationTrain,
                SetReservedLTADDR,
                DeleteReservedLTADDR,
                SetConnectionlessSlaveBroadcastData,
                ReadSynchronizationTrainParameters,
                WriteSynchronizationTrainParameters,
                RemoteOOBExtendedDataRequestReply,
                ReadSecureConnectionsHostSupport,
                WriteSecureConnectionsHostSupport,
                ReadAuthenticatedPayloadTimeout,
                WriteAuthenticatedPayloadTimeout,
                ReadLocalOOBExtendedData,
                WriteSecureConnectionsTestMode,
                ReadExtendedPageTimeout,
                WriteExtendedPageTimeout,
                ReadExtendedInquiryLength,
                WriteExtendedInquiryLengh,
                LERemoteConnectionParameterRequestReply,
                LERemoteConnectionParameterREquestNegativeReply,
                LESetDataLength,
                LEReadSuggestedDefaultDataLength,
                LEWriteSuggestedDefaultDataLength,
                LEReadLocalP256PublicKey,
                LEGenerateDHKey,
                LEAddDeviceToResolvingList,
                LERemoveDeviceFromResolvingList,
                LEClearResolvingList,
                LEReadResolvingListSize,
                LEReadPeerResolvableAddress,
                LEReadLocalResolvableAddress,
                LESetAddressResolutionEnable,
                LESetResolvablePrivateAddressTimeout,
                LEReadMaximumDataLength,
                LEReadPHYCommand,
                LESetDefaultPHYCommand,
                LESetPHYCommand,
                LEEnhancedReceiverTestCommand,
                LEEnhancedTransmitterTestCommand,
                LESetAdvertisingSetRandomAddressCommand,
                LESetExtendedAdvertisingParametersCommand,
                LESetExtendedAdvertisingDataCommand,
                LESetExtendedScanResponseDataCommand,
                LESetExtendedAdvertisingEnableCommand,
                LEReadMaximumAdvertisingDataLengthCommand,
                LEReadNumberOfSupportedAdvertisingSetCommand,
                LERemoveAdvertisingSetCommand,
                LEClearAdvertisingSetsCommand,
                LESetPeriodicAdvertisingParametersCommand,
                LESetPeriodicAdvertisingDataCommand,
                LESetPeriodicAdvertisingEnableCommand,
                LESetExtendedScanParametersCommand,
                LESetExtendedScanEnableCommand,
                LEExtendedCreateConnectionCommand,
                LEPeriodicAdvertisingCreateSyncCommand,
                LEPeriodicAdvertisingCreateSyncCancelCommand,
                LEPeriodicAdvertisingTerminateSyncCommand,
                LEAddDeviceToPeriodicAdvertiserListCommand,
                LERemoveDeviceFromPeriodicAdvertiserListCommand,
                LEClearPeriodicAdvertiserListCommand,
                LEReadPeriodicAdvertiserListSizeCommand,
                LEReadTransmitPowerCommand,
                LEReadRFPathCompensationCommand,
                LEWriteRFPathCompensationCommand,
                LESetPrivacyMode,
            }

            impl SupportedCommands {

                fn from_bit_pos( pos: (usize, usize) ) -> Option<SupportedCommands> {
                    use self::SupportedCommands::*;

                    match pos {
                        (0,0)  => Some(Inquiry),
                        (0,1)  => Some(InquiryCancel),
                        (0,2)  => Some(PeriodicInquiryMode),
                        (0,3)  => Some(ExitPeriodicInquiryMode),
                        (0,4)  => Some(CreateConnection),
                        (0,5)  => Some(Disconnect),
                        (0,6)  => Some(AddSCOConnection),
                        (0,7)  => Some(CreateConnectionCancel),
                        (1,0)  => Some(AcceptConnectionRequest),
                        (1,1)  => Some(RejectConnectionRequest),
                        (1,2)  => Some(LinkKeyRequestReply),
                        (1,3)  => Some(LinkKeyRequestNegativeReply),
                        (1,4)  => Some(PINCodeRequestReply),
                        (1,5)  => Some(PINCodeRequestNegativeReply),
                        (1,6)  => Some(ChangeConnectionPacketType),
                        (1,7)  => Some(AuthenticationRequested),
                        (2,0)  => Some(SetConnectionEncryption),
                        (2,1)  => Some(ChangeConnectionLinkKey),
                        (2,2)  => Some(MasterLinkKey),
                        (2,3)  => Some(RemoteNameRequest),
                        (2,4)  => Some(RemoteNameRequestCancel),
                        (2,5)  => Some(ReadRemoteSupportedFeatures),
                        (2,6)  => Some(ReadRemoteExtendedFeatures),
                        (2,7)  => Some(ReadRemoteVersionInformation),
                        (3,0)  => Some(ReadClockOffset),
                        (3,1)  => Some(ReadLMPHandle),
                        (4,1)  => Some(HoldMode),
                        (4,2)  => Some(SniffMode),
                        (4,3)  => Some(ExitSniffMode),
                        (4,6)  => Some(QosSetup),
                        (4,7)  => Some(RoleDiscovery),
                        (5,0)  => Some(SwitchRole),
                        (5,1)  => Some(ReadLinkPolicySettings),
                        (5,2)  => Some(WriteLinkPolicySettings),
                        (5,3)  => Some(ReadDefaultLinkPolicySettings),
                        (5,4)  => Some(WriteDefaultLinkPolicySettings),
                        (5,5)  => Some(FlowSpecification),
                        (5,6)  => Some(SetEventMask),
                        (5,7)  => Some(Reset),
                        (6,0)  => Some(SetEVentFilter),
                        (6,1)  => Some(Flush),
                        (6,2)  => Some(ReadPINType),
                        (6,3)  => Some(WritePINType),
                        (6,4)  => Some(CreateNewUnitKey),
                        (6,5)  => Some(ReadStoredLinkKey),
                        (6,6)  => Some(WriteStoredLinkKey),
                        (6,7)  => Some(DeleteStoredLinkKey),
                        (7,0)  => Some(WriteLocalName),
                        (7,1)  => Some(ReadLocalName),
                        (7,2)  => Some(ReadConnectionAcceptedTimeout),
                        (7,3)  => Some(WriteConnectionAcceptedTimeout),
                        (7,4)  => Some(ReadPageTimeout),
                        (7,5)  => Some(WritePageTimeout),
                        (7,6)  => Some(ReadScanEnable),
                        (7,7)  => Some(WriteScanEnable),
                        (8,0)  => Some(ReadPageScanActivity),
                        (8,1)  => Some(WritePageScanActivity),
                        (8,2)  => Some(ReadInquiryScanActivity),
                        (8,3)  => Some(WriteInquiryScanActivity),
                        (8,4)  => Some(ReadAuthenticationEnable),
                        (8,5)  => Some(WriteAuthenticationEnable),
                        (8,6)  => Some(ReadEncryptionMode),
                        (8,7)  => Some(WriteEncryptionMode),
                        (9,0)  => Some(ReadClassOfDevice),
                        (9,1)  => Some(WriteClassOfDevice),
                        (9,2)  => Some(REadVoiceSetting),
                        (9,3)  => Some(WriteVoiceSetting),
                        (9,4)  => Some(ReadAutomaticFlushTimeout),
                        (9,5)  => Some(WriteAutomaticFlushTimeout),
                        (9,6)  => Some(ReadNumBroadcastRetransmission),
                        (9,7)  => Some(WriteNumBroadcastRetransmissions),
                        (10,0) => Some(ReadHoldModeActivity),
                        (10,1) => Some(WriteHoldModeActiviy),
                        (10,2) => Some(ReadTransmitPowerLevel),
                        (10,3) => Some(ReadSynchronousFlowControlEnable),
                        (10,4) => Some(WriteSynchronousFlowControlEnable),
                        (10,5) => Some(SetConrollerToHostFlowControl),
                        (10,6) => Some(HostBufferSize),
                        (10,7) => Some(HostNumberOfCompletedPackets),
                        (11,0) => Some(ReadLinkSupervisionTimeout),
                        (11,1) => Some(WriteLinkSupervisionTimeout),
                        (11,2) => Some(ReadNumberOfSupportedIAC),
                        (11,3) => Some(ReadCurrentIACLAP),
                        (11,4) => Some(WriteCurrentIACLAP),
                        (11,5) => Some(ReadPageScanModePeriod),
                        (11,6) => Some(WritePageScanModePeriod),
                        (11,7) => Some(ReadPageScanMode),
                        (12,0) => Some(WritePageSanMode),
                        (12,1) => Some(SetAFHHostChannel),
                        (12,4) => Some(ReadInquiryScanType),
                        (12,5) => Some(WriteInquirySCanType),
                        (12,6) => Some(ReadInquiryMode),
                        (12,7) => Some(WriteInquiryMode),
                        (13,0) => Some(ReadPageScanType),
                        (13,1) => Some(WritePageScanType),
                        (13,2) => Some(ReadAFHChannelAssessmentMode),
                        (13,3) => Some(WriteAFHChannelAssessmentMode),
                        (14,3) => Some(ReadLocalVersionInformation),
                        (14,5) => Some(ReadLocalSupportedFeatures),
                        (14,6) => Some(ReadLocalExtendedFeatures),
                        (14,7) => Some(ReadBufferSize),
                        (15,0) => Some(ReadCountryCode),
                        (15,1) => Some(ReadBDADDR),
                        (15,2) => Some(ReadFAiledContactCounter),
                        (15,3) => Some(ResetFailedContactCounter),
                        (15,4) => Some(ReadLinkQuality),
                        (15,5) => Some(ReadRSSI),
                        (15,6) => Some(ReadAFHChannelMap),
                        (15,7) => Some(ReadClock),
                        (16,0) => Some(ReadLoopbackMode),
                        (16,1) => Some(WriteLoopbackMode),
                        (16,2) => Some(EnableDeviceUnderTestMode),
                        (16,3) => Some(SetupSynchronousConnectionRequest),
                        (16,4) => Some(AcceptSynchronousConnectionRequest),
                        (16,5) => Some(RejectSynchronousConnectionRequest),
                        (17,0) => Some(ReadExtendedInquiryResponse),
                        (17,1) => Some(WriteExtendedInquiryResponse),
                        (17,2) => Some(RefreshEncryptionKey),
                        (17,4) => Some(SniffSubrating),
                        (17,5) => Some(ReadSimplePairingMode),
                        (17,6) => Some(WriteSimplePairingMode),
                        (17,7) => Some(ReadLocalOOBData),
                        (18,0) => Some(ReadInquiryResponseTransmitPowerLevel),
                        (18,1) => Some(WriteInquiryTransmitPowerLevel),
                        (18,2) => Some(ReadDefaultErroneousDataReporting),
                        (18,3) => Some(WriteDefaultErroneousDataReporting),
                        (18,7) => Some(IOCapabilityRequestReply),
                        (19,0) => Some(UserConfirmationRequestReply),
                        (19,1) => Some(UserConfirmationRequestNegativeReply),
                        (19,2) => Some(UserPasskeyRequestReply),
                        (19,3) => Some(UserPasskeyRequestNegativeReply),
                        (19,4) => Some(RemoteOOBDataRequestReply),
                        (19,5) => Some(WriteSimplePairingDebugMode),
                        (19,6) => Some(EnhancedFlush),
                        (19,7) => Some(RemoteOOBDataRequestNagativeReply),
                        (20,2) => Some(SendKeypressNotification),
                        (20,3) => Some(IOCapabilityRequestNegativeReply),
                        (20,4) => Some(ReadEncryptionKeySize),
                        (21,0) => Some(CreatePhysicalLink),
                        (21,1) => Some(AcceptPhysicalLink),
                        (21,2) => Some(DisconnectPhysicalLink),
                        (21,3) => Some(CreateLogicalLink),
                        (21,4) => Some(AcceptLogicalLink),
                        (21,5) => Some(DisconnectLogicalLink),
                        (21,6) => Some(LogicalLinkCancel),
                        (21,7) => Some(FlowSpecModify),
                        (22,0) => Some(ReadLogicalLinkAcceptTimeout),
                        (22,1) => Some(WriteLogicalLinkAcceptTimeout),
                        (22,2) => Some(SetEventMaskPage2),
                        (22,3) => Some(ReadLocationData),
                        (22,4) => Some(WRiteLocationData),
                        (22,5) => Some(ReadLocalAMPInfo),
                        (22,6) => Some(ReadLocalAMPASSOC),
                        (22,7) => Some(WriteRemoteAMPASSOC),
                        (23,0) => Some(READFlowControlMode),
                        (23,1) => Some(WriteFlowControlMode),
                        (23,2) => Some(ReadDataBlockSize),
                        (23,5) => Some(EnableAMPReceiverReports),
                        (23,6) => Some(AMPTestEnd),
                        (23,7) => Some(AmPTest),
                        (24,0) => Some(ReadEnhancedTransmitPowerLevel),
                        (24,2) => Some(ReadBestEffortFlushTimeout),
                        (24,3) => Some(WriteBestEffortFlushTimeout),
                        (24,4) => Some(ShortRangeMode),
                        (24,5) => Some(ReadLEHostSupport),
                        (24,6) => Some(WriteLEHostSupport),
                        (25,0) => Some(LESetEventMask),
                        (25,1) => Some(LEReadBufferSize),
                        (25,2) => Some(LEReadLocalSupportedFeatures),
                        (25,4) => Some(LESetRandomAddress),
                        (25,5) => Some(LESetAdvertisingParameters),
                        (25,6) => Some(LEReadAdvertisingChannelTXPower),
                        (25,7) => Some(LESetAdvertisingData),
                        (26,0) => Some(LESetScanResponseData),
                        (26,1) => Some(LESetAdvertisingEnable),
                        (26,2) => Some(LESetScanParameters),
                        (26,3) => Some(LESetScanEnable),
                        (26,4) => Some(LECreateConnection),
                        (26,5) => Some(LECreateConnectionCancel),
                        (26,6) => Some(LEReadWhiteListSize),
                        (26,7) => Some(LEClearWhiteList),
                        (27,0) => Some(LEAddDeviceToWhiteList),
                        (27,1) => Some(LERemoveDeviceFromWhiteList),
                        (27,2) => Some(LEConnectionUpdate),
                        (27,3) => Some(LESetHostChannelClassification),
                        (27,4) => Some(LEReadChannelMap),
                        (27,5) => Some(LEReadRemoteFeatures),
                        (27,6) => Some(LEEncrypt),
                        (27,7) => Some(LERand),
                        (28,0) => Some(LEStartEncryption),
                        (28,1) => Some(LELongTermKeyRequestReply),
                        (28,2) => Some(LELongTermKeyRequestNegativeReply),
                        (28,3) => Some(LEReadSupportedStates),
                        (28,4) => Some(LEReceiverTest),
                        (28,5) => Some(LETransmitterTest),
                        (28,6) => Some(LETestEnd),
                        (29,3) => Some(EnhancedSetupSynchronousConnection),
                        (29,4) => Some(EnhancedAcceptSynchronousConnection),
                        (29,5) => Some(ReadLocalSupportedCondecs),
                        (29,6) => Some(SetMWSChannelParameters),
                        (29,7) => Some(SetExternalFrameConfiguration),
                        (30,0) => Some(SetMWSSignaling),
                        (30,1) => Some(SetMWSTransportLayer),
                        (30,2) => Some(SetMWSScanFrequencyTable),
                        (30,3) => Some(GetMWSTransportLayerConfiguration),
                        (30,4) => Some(SetMWSPATTERNConfiguration),
                        (30,5) => Some(SetTriggeredClockCapture),
                        (30,6) => Some(TruncatedPage),
                        (30,7) => Some(TruncatedPageCancel),
                        (31,0) => Some(SetConnectionlessSlaveBroadcast),
                        (31,1) => Some(SetConnectionlessSlaveBroadcastReceive),
                        (31,2) => Some(StartSynchronizationTrain),
                        (31,3) => Some(ReceiveSynchronizationTrain),
                        (31,4) => Some(SetReservedLTADDR),
                        (31,5) => Some(DeleteReservedLTADDR),
                        (31,6) => Some(SetConnectionlessSlaveBroadcastData),
                        (31,7) => Some(ReadSynchronizationTrainParameters),
                        (32,0) => Some(WriteSynchronizationTrainParameters),
                        (32,1) => Some(RemoteOOBExtendedDataRequestReply),
                        (32,2) => Some(ReadSecureConnectionsHostSupport),
                        (32,3) => Some(WriteSecureConnectionsHostSupport),
                        (32,4) => Some(ReadAuthenticatedPayloadTimeout),
                        (32,5) => Some(WriteAuthenticatedPayloadTimeout),
                        (32,6) => Some(ReadLocalOOBExtendedData),
                        (32,7) => Some(WriteSecureConnectionsTestMode),
                        (33,0) => Some(ReadExtendedPageTimeout),
                        (33,1) => Some(WriteExtendedPageTimeout),
                        (33,2) => Some(ReadExtendedInquiryLength),
                        (33,3) => Some(WriteExtendedInquiryLengh),
                        (33,4) => Some(LERemoteConnectionParameterRequestReply),
                        (33,5) => Some(LERemoteConnectionParameterREquestNegativeReply),
                        (33,6) => Some(LESetDataLength),
                        (33,7) => Some(LEReadSuggestedDefaultDataLength),
                        (34,0) => Some(LEWriteSuggestedDefaultDataLength),
                        (34,1) => Some(LEReadLocalP256PublicKey),
                        (34,2) => Some(LEGenerateDHKey),
                        (34,3) => Some(LEAddDeviceToResolvingList),
                        (34,4) => Some(LERemoveDeviceFromResolvingList),
                        (34,5) => Some(LEClearResolvingList),
                        (34,6) => Some(LEReadResolvingListSize),
                        (34,7) => Some(LEReadPeerResolvableAddress),
                        (35,0) => Some(LEReadLocalResolvableAddress),
                        (35,1) => Some(LESetAddressResolutionEnable),
                        (35,2) => Some(LESetResolvablePrivateAddressTimeout),
                        (35,3) => Some(LEReadMaximumDataLength),
                        (35,4) => Some(LEReadPHYCommand),
                        (35,5) => Some(LESetDefaultPHYCommand),
                        (35,6) => Some(LESetPHYCommand),
                        (35,7) => Some(LEEnhancedReceiverTestCommand),
                        (36,0) => Some(LEEnhancedTransmitterTestCommand),
                        (36,1) => Some(LESetAdvertisingSetRandomAddressCommand),
                        (36,2) => Some(LESetExtendedAdvertisingParametersCommand),
                        (36,3) => Some(LESetExtendedAdvertisingDataCommand),
                        (36,4) => Some(LESetExtendedScanResponseDataCommand),
                        (36,5) => Some(LESetExtendedAdvertisingEnableCommand),
                        (36,6) => Some(LEReadMaximumAdvertisingDataLengthCommand),
                        (36,7) => Some(LEReadNumberOfSupportedAdvertisingSetCommand),
                        (37,0) => Some(LERemoveAdvertisingSetCommand),
                        (37,1) => Some(LEClearAdvertisingSetsCommand),
                        (37,2) => Some(LESetPeriodicAdvertisingParametersCommand),
                        (37,3) => Some(LESetPeriodicAdvertisingDataCommand),
                        (37,4) => Some(LESetPeriodicAdvertisingEnableCommand),
                        (37,5) => Some(LESetExtendedScanParametersCommand),
                        (37,6) => Some(LESetExtendedScanEnableCommand),
                        (37,7) => Some(LEExtendedCreateConnectionCommand),
                        (38,0) => Some(LEPeriodicAdvertisingCreateSyncCommand),
                        (38,1) => Some(LEPeriodicAdvertisingCreateSyncCancelCommand),
                        (38,2) => Some(LEPeriodicAdvertisingTerminateSyncCommand),
                        (38,3) => Some(LEAddDeviceToPeriodicAdvertiserListCommand),
                        (38,4) => Some(LERemoveDeviceFromPeriodicAdvertiserListCommand),
                        (38,5) => Some(LEClearPeriodicAdvertiserListCommand),
                        (38,6) => Some(LEReadPeriodicAdvertiserListSizeCommand),
                        (38,7) => Some(LEReadTransmitPowerCommand),
                        (39,0) => Some(LEReadRFPathCompensationCommand),
                        (39,1) => Some(LEWriteRFPathCompensationCommand),
                        (39,2) => Some(LESetPrivacyMode),
                        _      => None
                    }
                }

                // TODO re-make this private
                pub(crate) fn try_from( packed: CmdReturn ) -> Result<Vec<Self>, error::Error> {

                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {

                        let mut sup_commands = Vec::new();

                        let raw = &packed.supported_commands;

                        for indx in 0..raw.len() {
                            for bit in 0..8 {
                                if 0 != raw[indx] & (1 << bit) {
                                    if let Some(command) = Self::from_bit_pos((indx,bit)) {
                                        sup_commands.push(command);
                                    }
                                }
                            }
                        }

                        Ok(sup_commands)
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                SupportedCommands,
                Vec<SupportedCommands>,
                error::Error
            );

            impl_command_data_future!(SupportedCommands, Vec<SupportedCommands>, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<Vec<SupportedCommands>, impl Display + Debug>>  {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;
                use test::Bencher;

                #[test]
                fn ip_read_local_supported_commands_test() {
                    block_for_result(send(&HostInterface::default())).unwrap();

                }

                #[bench]
                fn ip_read_local_supported_commands_bench( b: &mut Bencher ) {
                    let hci = HostInterface::default();

                    b.iter(|| block_for_result(send(&hci)));
                }

                #[bench]
                /// The hope is that converting the raw bits to a vector of commands is much faster
                /// then the response from the controller (which is what
                /// ip_read_local_supported_features_bench does)
                fn supported_commands_from_raw_bench( b: &mut Bencher) {

                    // Should be the worse than the worst case from the hci return for
                    // performance reasons.
                    b.iter( || { SupportedCommands::try_from(CmdReturn {
                        status : 0,
                        supported_commands: [0xFFu8;64], // worst case scenerio
                    }) } );
                }
            }
        }
    }

    pub mod transmitter {
        pub mod read_advertising_channel_tx_power {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReadAdvertisingChannelTxPower);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                tx_power_level: i8
            }

            /// The LE Read Advertising Channel Tx Power Command returns dBm, a unit of power
            /// provided to the radio antenna.
            #[derive(Debug)]
            pub struct TxPower(i8);

            impl TxPower {

                fn try_from(packed: CmdReturn) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(TxPower(packed.tx_power_level))
                    }
                    else {
                        Err(status)
                    }
                }

                pub fn into_milli_watts(&self) -> f32 {
                    use core::f32;
                    10f32.powf( self.0 as f32 / 10f32 )
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                TxPower,
                error::Error
            );

            impl_command_data_future!(TxPower, error::Error);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send( hci: &HostInterface )
            -> impl Future<Output=Result<TxPower, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn read_advertising_channel_tx_power_test() {
                    block_for_result(send(&HostInterface::default())).unwrap();

                }

                #[test]
                fn tx_power_into_watts_test() {
                    // just some data from wikipedia's dBm page
                    let test_data = [(29i8, 794f32), (24i8,251f32), (-20i8, 10E-6f32)];

                    let fudge_factor = 0.5;

                    let fudge = | act: f32, exp: f32 | {
                        ( exp + fudge_factor > act ) && ( exp - fudge_factor < act )
                    };

                    let dbg_out = | act, exp | {
                        format!("act: {:?}, exp: {:?}, fudge: {:?}", act, exp, fudge_factor)
                    };

                    for (dbm, exp_mw) in test_data.iter() {
                        let act_mw = TxPower(*dbm).into_milli_watts();

                        assert!(fudge(act_mw,*exp_mw), "{}", dbg_out(act_mw,*exp_mw));
                    }
                }
            }
        }
        pub mod transmitter_test{

            use crate::hci::*;
            use crate::hci::le::common::Frequency;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::TransmitterTest);

            #[repr(packed)]
            #[derive( Clone, Copy)]
            struct CmdParameter {
                _tx_channel: u8,
                _lenght_of_test_data: u8,
                _packet_payload: u8,
            }

            #[cfg_attr(test,derive(Debug))]
            pub enum TestPayload {
                PRBS9Sequence,
                Repeat11110000,
                Repeat10101010,
                PRBS15Sequence,
                Repeat11111111,
                Repeat00000000,
                Repeat00001111,
                Repeat01010101,
            }

            impl TestPayload {
                fn into_val(&self) -> u8 {
                    use self::TestPayload::*;
                    match *self {
                        PRBS9Sequence  => 0x00u8,
                        Repeat11110000 => 0x01u8,
                        Repeat10101010 => 0x02u8,
                        PRBS15Sequence => 0x03u8,
                        Repeat11111111 => 0x04u8,
                        Repeat00000000 => 0x05u8,
                        Repeat00001111 => 0x06u8,
                        Repeat01010101 => 0x07u8,
                    }
                }
            }

            impl_status_return!(COMMAND);

            impl CommandParameters for CmdParameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {*self}
            }

            pub fn send(
                hci: &HostInterface,
                channel: Frequency,
                payload: TestPayload,
                payload_length: u8 )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {

                let parameters = CmdParameter {
                    _tx_channel: channel.get_val(),
                    _lenght_of_test_data: payload_length,
                    _packet_payload: payload.into_val(),
                };

                ReturnedFuture( hci.send_command(parameters, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use crate::hci::le::mandatory::test_end;
                use std::{thread, time};
                use crate::hci::test_util::block_for_result;

                #[test]
                #[ignore]
                fn transmitter_test_test() {
                    let hi = HostInterface::default();

                    let payload = TestPayload::Repeat11110000;
                    let frequency = Frequency::new( 2460 ).unwrap();
                    let payload_len = 2u8;

                    let sleep_duration = time::Duration::new(1,0);

                    block_for_result(send(&hi, frequency, payload, payload_len)).unwrap();

                    thread::sleep(sleep_duration);

                    block_for_result(test_end::send(&HostInterface::default()))
                        .unwrap();
                }
            }
        }

        pub mod set_advertising_data {

            use crate::hci::*;
            use crate::gap::advertise::{IntoRaw,DataTooLargeError};

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetAdvertisingData);

            type Payload = [u8;31];

            #[repr(packed)]
            pub(crate) struct CmdParameter {
                _length: u8,
                _data: [u8;31],
            }

            /// Advertising data
            ///
            /// The Adevertising data is made up of AD Structs. The maximum amount of bytes a
            /// regular advertising broadcast can send is 30 bytes (look at extended
            /// advertising for a larger payload). The total payload is 1 byte for the length,
            /// and 30 bytes for the AD structures. The data can consist of as many AD structs
            /// that can fit in it, but it must consist of at least one AD struct (unless
            /// early termination is desired).
            #[derive(Debug,Clone,Copy)]
            pub struct AdvertisingData {
                length: usize,
                payload: Payload,
            }

            impl AdvertisingData {

                /// Create an empty advertising data
                ///
                /// This is exactly the same as the function early_terminate, but makes more
                /// "readable" sense to use this in conjuntion with try_push.
                #[inline]
                pub fn new() -> Self {
                    Self::early_terminate()
                }

                /// Ealy termination of advertising
                ///
                /// This can also be use to build AdvertisingData object from an "empty" state,
                /// but it is recommended to use the try_from method.
                ///
                /// ```rust
                /// use bo_tie_linux::hci::le::transmitter::command::set_advertising_data::{ADStruct,AdvertisingData};
                ///
                /// // try to use the try_from method instead of doing it this way.
                /// let mut ad = AdvertisingData::early_terminate();
                ///
                /// ad.try_push( ADStruct {ad_type: 0x01u8, data: &[0x00u8]} ).unwrap();
                /// ```
                pub fn early_terminate() -> Self {
                    AdvertisingData{
                        length: 0,
                        payload: Payload::default(),
                    }
                }

                /// Add an ADStruct to the advertising data
                ///
                /// Returns self if the data was added to the advertising data
                ///
                /// # Error
                /// 'data' in its transmission form was too large for remaining free space in
                /// the advertising data.
                pub fn try_push<T>(&mut self, data: T )
                    -> Result<(), DataTooLargeError>
                    where T: IntoRaw
                {
                    let raw_data = data.into_raw();

                    if raw_data.len() + self.length <= self.payload.len() {
                        let old_len = self.length;

                        self.length += raw_data.len();

                        self.payload[old_len..self.length].copy_from_slice(&raw_data);

                        Ok(())
                    }
                    else {
                        Err(DataTooLargeError {
                            overflow: raw_data.len() + self.length - self.payload.len(),
                            remaining: self.payload.len() - self.length,
                        })
                    }
                }

                /// Get the remaining amount of space available for ADStructures
                ///
                /// Use this to get the remaining space that can be sent in an advertising
                /// packet.
                pub fn remaining_space(&self) -> usize {
                    self.payload.len() - self.length as usize
                }
            }

            impl CommandParameters for AdvertisingData{
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    CmdParameter {
                        _length: self.length as u8,
                        _data: self.payload,
                    }
                }
            }

            impl_status_return!(COMMAND);

            pub fn send( hci: &HostInterface, adv_data: AdvertisingData )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(adv_data, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn set_advertising_data_test() {

                    use crate::gap::advertise::{flags,local_name};

                    let mut flags = flags::Flags::new();

                    flags.get_user(0).enable();
                    flags.get_user(20).enable();

                    let local_name = local_name::LocalName::new("Test", false);

                    let mut ad = AdvertisingData::new();
                    ad.try_push(flags).unwrap();
                    ad.try_push(local_name).unwrap();

                    block_for_result(send(&HostInterface::default(), ad)).unwrap();

                }

                #[test]
                fn advertising_data_try_from_test () {

                    use crate::gap::advertise::{flags,local_name};

                    let mut flags = flags::Flags::new();

                    flags.get_user(11).enable();
                    flags.get_user(8*3).enable();

                    let too_long_name = local_name::LocalName::new("Supercalifragilisticexpialidocious", true);

                    AdvertisingData::new()
                    .try_push(flags)
                    .unwrap();

                    AdvertisingData::new()
                    .try_push(too_long_name)
                    .unwrap_err();
                }

                #[test]
                fn advertising_data_try_push_test () {
                    use crate::gap::advertise::local_name::LocalName;
                    use std::str::from_utf8;

                    let local_name_1 = LocalName::new("abcdefghijklm", true);
                    let local_name_2 = LocalName::new("012345678901234", false);
                    let local_name_too_long = LocalName::new(from_utf8(&[102u8;31]).unwrap(), false);

                    let mut test_ad_1 = AdvertisingData::early_terminate();
                    let mut test_ad_2 = AdvertisingData::early_terminate();

                    assert!(test_ad_1.try_push( local_name_1 ).is_ok());

                    assert!(test_ad_1.try_push( local_name_2 ).is_err());

                    assert!(test_ad_2.try_push( local_name_too_long ).is_err());
                }
            }
        }
        pub mod set_advertising_enable {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetAdvertisingEnable);

            impl_status_return!(COMMAND);

            #[derive(Clone,Copy)]
            struct Parameter{
                enable: bool
            }

            impl CommandParameters for Parameter {
                type Parameter = u8;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    if self.enable { 1u8 } else { 0u8 }
                }
            }

            pub fn send( hci: &HostInterface, enable: bool ) -> impl Future<Output=Result<(), impl Display + Debug>> {
                ReturnedFuture( hci.send_command(Parameter{ enable: enable }, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use super::super::set_advertising_data;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn set_advertising_enable_test() {
                    use crate::gap::advertise::local_name::LocalName;

                    let hci = HostInterface::default();

                    let mut payload = set_advertising_data::AdvertisingData::new();

                    payload.try_push(LocalName::new("ENABLE BLE TEST", true)).unwrap();

                    block_for_result(set_advertising_data::send(&hci, payload)).unwrap();

                    block_for_result(send(&hci, true)).unwrap();

                    block_for_result(send(&hci, false)).unwrap();
                }
            }
        }
        pub mod set_advertising_parameters {

            use crate::hci::*;
            use crate::hci::le::common::OwnAddressType;
            use core::default::Default;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetAdvertisingParameters);

            interval!( AdvertisingInterval, 0x0020, 0x4000, SpecDef, 0x0800, 625);

            /// Advertising Type
            ///
            /// Enumeration for the 'Advertising Type' advertising parameter.
            #[cfg_attr(test,derive(Debug))]
            pub enum AdvertisingType {
                ConnectableAndScannableUndirectedAdvertising,
                ConnectableHighDucyCycleDirectedAdvertising,
                ScannableUndirectedAdvertising,
                NonConnectableUndirectedAdvertising,
                ConnectableLowDutyCycleDirectedAdvertising,
            }

            impl AdvertisingType {

                fn into_val(&self) -> u8 {
                    match *self {
                        AdvertisingType::ConnectableAndScannableUndirectedAdvertising => 0x00,
                        AdvertisingType::ConnectableHighDucyCycleDirectedAdvertising => 0x01,
                        AdvertisingType::ScannableUndirectedAdvertising => 0x02,
                        AdvertisingType::NonConnectableUndirectedAdvertising => 0x03,
                        AdvertisingType::ConnectableLowDutyCycleDirectedAdvertising => 0x04,
                    }
                }
            }

            impl Default for AdvertisingType {
                fn default() -> Self {
                    AdvertisingType::ConnectableAndScannableUndirectedAdvertising
                }
            }

            /// Peer address type
            ///
            /// # Notes (from core 5.0 specification)
            /// - PublicAddress -> Public Device Address (default) or Public Identity Address
            /// - RandomAddress -> Random Device Address or Random (static) Identity Address
            #[cfg_attr(test,derive(Debug))]
            pub enum PeerAddressType {
                PublicAddress,
                RandomAddress,
            }

            impl PeerAddressType {
                fn into_val(&self) -> u8 {
                    match *self {
                        PeerAddressType::PublicAddress => 0x00,
                        PeerAddressType::RandomAddress => 0x01,
                    }
                }
            }

            impl Default for PeerAddressType {
                fn default() -> Self {
                    PeerAddressType::PublicAddress
                }
            }

            /// Advertising channels
            #[cfg_attr(test,derive(Debug))]
            pub enum AdvertisingChannel {
                Channel37,
                Channel38,
                Channel39,
            }

            impl AdvertisingChannel {
                fn into_val(&self) -> u8 {
                    match *self {
                        AdvertisingChannel::Channel37 => 0x01,
                        AdvertisingChannel::Channel38 => 0x02,
                        AdvertisingChannel::Channel39 => 0x04,
                    }
                }

                pub fn default_channels() -> &'static [AdvertisingChannel] {
                    &[
                        AdvertisingChannel::Channel37,
                        AdvertisingChannel::Channel38,
                        AdvertisingChannel::Channel39,
                    ]
                }
            }

            #[cfg_attr(test,derive(Debug))]
            pub enum AdvertisingFilterPolicy {
                AllDevices,
                AllConnectionRequestsWhitlistedDeviceScanRequests,
                AllScanRequestsWhitlistedDeviceConnectionRequests,
                WhitelistedDevices,
            }

            impl AdvertisingFilterPolicy {
                fn into_val(&self) -> u8 {
                    match *self {
                        AdvertisingFilterPolicy::AllDevices => 0x00,
                        AdvertisingFilterPolicy::AllConnectionRequestsWhitlistedDeviceScanRequests => 0x01,
                        AdvertisingFilterPolicy::AllScanRequestsWhitlistedDeviceConnectionRequests => 0x02,
                        AdvertisingFilterPolicy::WhitelistedDevices => 0x03,
                    }
                }
            }

            impl Default for AdvertisingFilterPolicy {
                fn default() -> Self {
                    AdvertisingFilterPolicy::AllDevices
                }
            }

            /// All the parameters required for advertising
            ///
            /// For the advertising_channel_map, provide a slice containing every channels
            /// desired to be advertised on.
            ///
            /// While most members are public, the only way to set the minimum and maximum
            /// advertising interval is through method calls.
            #[cfg_attr(test,derive(Debug))]
            pub struct AdvertisingParameters<'a> {
                pub minimum_advertising_interval: AdvertisingInterval,
                pub maximum_advertising_interval: AdvertisingInterval,
                pub advertising_type: AdvertisingType,
                pub own_address_type: OwnAddressType,
                pub peer_address_type: PeerAddressType,
                pub peer_address: crate::BluetoothDeviceAddress,
                pub advertising_channel_map: &'a[AdvertisingChannel],
                pub advertising_filter_policy: AdvertisingFilterPolicy,
            }

            impl<'a> Default for AdvertisingParameters<'a> {

                /// Create an AdvertisingParameters object with the default parameters (except
                /// for the peer_address member).
                ///
                /// The default parameter values are from the bluetooth core 5.0 specification,
                /// however there is no default value for the peer_address. This function sets
                /// the peer_address to zero, so it must be set after if a connection to a
                /// specific peer device is desired.
                fn default() -> Self {
                    AdvertisingParameters {
                        minimum_advertising_interval: AdvertisingInterval::default(),
                        maximum_advertising_interval: AdvertisingInterval::default(),
                        advertising_type: AdvertisingType::default(),
                        own_address_type: OwnAddressType::default(),
                        peer_address_type: PeerAddressType::default(),
                        peer_address: [0u8;6].into(),
                        advertising_channel_map: AdvertisingChannel::default_channels(),
                        advertising_filter_policy: AdvertisingFilterPolicy::default(),
                    }
                }
            }

            impl<'a> AdvertisingParameters<'a> {

                /// Create the default parameters except use the specified bluetooth device
                /// address for the peer_address member
                pub fn default_with_peer_address( addr: &'a crate::BluetoothDeviceAddress) ->
                        AdvertisingParameters
                {
                    let mut ap = AdvertisingParameters::default();

                    ap.peer_address = *addr;

                    ap
                }
            }

            #[repr(packed)]
            #[derive( Clone, Copy)]
            struct CmdParameter {
                _advertising_interval_min: u16,
                _advertising_interval_max: u16,
                _advertising_type: u8,
                _own_address_type: u8,
                _peer_address_type: u8,
                _peer_address: crate::BluetoothDeviceAddress,
                _advertising_channel_map: u8,
                _advertising_filter_policy: u8,
            }

            impl CommandParameters for CmdParameter{
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_status_return!(COMMAND);

            pub fn send( hci: &HostInterface, params: AdvertisingParameters )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {

                let parameter = CmdParameter {

                    _advertising_interval_min: params.minimum_advertising_interval.get_raw_val(),

                    _advertising_interval_max: params.maximum_advertising_interval.get_raw_val(),

                    _advertising_type: params.advertising_type.into_val(),

                    _own_address_type: params.own_address_type.into_val(),

                    _peer_address_type: params.peer_address_type.into_val(),

                    _peer_address: params.peer_address.into(),

                    _advertising_channel_map: params.advertising_channel_map.iter().fold(0u8, |v, x| v | x.into_val()),

                    _advertising_filter_policy: params.advertising_filter_policy.into_val(),
                };

                ReturnedFuture( hci.send_command(parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::time::Duration;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn advertising_interval_test() {

                    AdvertisingInterval::try_from_raw(0x0020).unwrap();

                    AdvertisingInterval::try_from_raw(0x0019).unwrap_err();

                    AdvertisingInterval::try_from_raw(0x4000).unwrap();

                    AdvertisingInterval::try_from_raw(0x4001).unwrap_err();

                    AdvertisingInterval::try_from_duration(Duration::from_millis(20)).unwrap();

                    AdvertisingInterval::try_from_duration(Duration::from_nanos(19999999)).unwrap_err();

                    AdvertisingInterval::try_from_duration(Duration::new(10, 24000000)).unwrap();

                    AdvertisingInterval::try_from_duration(Duration::new(10, 24000001)).unwrap();
                }

                #[test]
                fn set_advertising_parameters_test() {
                    let params = AdvertisingParameters::default_with_peer_address(&[0x12;6]);

                    block_for_result(send( &HostInterface::default(), params)).unwrap();

                }

            }
        }
        pub mod set_random_address {

            use crate::hci::*;


            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetAdvertisingParameters);

            impl_status_return!(COMMAND);

            struct Parameter {
                rand_address: crate::BluetoothDeviceAddress
            }

            impl CommandParameters for Parameter {
                type Parameter = crate::BluetoothDeviceAddress;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    self.rand_address
                }
            }

            pub fn send( hci: &HostInterface, rand_addr: crate::BluetoothDeviceAddress )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(Parameter{ rand_address: rand_addr }, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests{

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn set_random_address_test() {

                    let static_address_flag = 0b11000000u8;

                    let addr = [0x11,0x22,0x33,0x44,0x55, (0x66 | static_address_flag) ];

                    block_for_result(send(&HostInterface::default(), addr)).unwrap();

                }
            }
        }
    }

    pub mod receiver {
        pub mod receiver_test {

            use crate::hci::*;
            use crate::hci::le::common::Frequency;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReceiverTest);

            impl_status_return!(COMMAND);

            impl CommandParameters for Frequency
            {
                type Parameter = u8;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    self.get_val()
                }
            }

            pub fn send( hci: &HostInterface, frequency: Frequency )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(frequency, events::Events::CommandComplete , Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                #[ignore]
                fn receiver_test_command_test() {

                    let frequency = Frequency::new(2420).unwrap();

                    block_for_result(send(&HostInterface::default(), frequency)).unwrap();

                }
            }
        }
        pub mod set_scan_enable {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetScanEnable);

            impl_status_return!(COMMAND);

            #[repr(packed)]
            struct CmdParameter {
                _enable: u8,
                _filter_duplicates: u8,
            }

            struct Parameter {
                enable: bool,
                filter_duplicates: bool,
            }

            impl CommandParameters for Parameter {
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    CmdParameter {
                        _enable: if self.enable {1} else {0},
                        _filter_duplicates: if self.filter_duplicates {1} else {0},
                    }
                }
            }

            /// The command has the ability to enable/disable scanning and filter duplicate
            /// advertisement.
            pub fn send( hci: &HostInterface, enable: bool, filter_duplicates: bool)
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                let cmd_param = Parameter {
                    enable: enable,
                    filter_duplicates: filter_duplicates,
                };

                ReturnedFuture( hci.send_command(cmd_param, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn set_scan_enable_test() {

                    #![allow(unreachable_code)]
                    panic!("Test not written correctly");

                    let hci = HostInterface::default();

                    block_for_result(send(&hci, true, true)).unwrap();

                    block_for_result(send(&hci, true, true)).unwrap();

                    block_for_result(send(&hci, false, true)).unwrap();

                    block_for_result(send(&hci, false, false)).unwrap();
                }
            }
        }
        pub mod set_scan_parameters {

            use crate::hci::*;
            use crate::hci::le::common::OwnAddressType;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetScanParameters);

            interval!( ScanningInterval, 0x0004, 0x4000, SpecDef, 0x0010, 625);
            interval!( ScanningWindow, 0x0004, 0x4000, SpecDef, 0x0010, 625);

            pub enum LEScanType {
                /// Under passive scanning, the link layer will not respond to any advertising
                /// packets. This is usefull when listening to a device in the broadcast role.
                PassiveScanning,
                /// With Active scanning, the link layer will send packets to the advertisier. These
                /// packets can be for quering for more data.
                ActiveScanning,
            }

            impl LEScanType {
                fn into_val(&self) -> u8 {
                    match *self {
                        LEScanType::PassiveScanning => 0x00,
                        LEScanType::ActiveScanning  => 0x01,
                    }
                }
            }

            impl Default for LEScanType {
                fn default() -> Self {
                    LEScanType::PassiveScanning
                }
            }

            /// See the spec on this one (v5.0 | Vol 2, Part E, 7.8.10) to understand what
            /// the enumerations are representing.
            ///
            /// Value mapping
            /// 0x00 => AcceptAll
            /// 0x01 => WhiteListed
            /// 0x02 => AcceptAllExceptIdentityNotAddressed
            /// 0x03 => AcceptAllExceptIdentityNotInWhitelist
            pub enum ScanningFilterPolicy {
                AcceptAll,
                WhiteListed,
                AcceptAllExceptIdentityNotAddressed,
                AcceptAllExceptIdentityNotInWhitelist,
            }

            impl ScanningFilterPolicy {
                fn into_val(&self) -> u8 {
                    match *self {
                        ScanningFilterPolicy::AcceptAll => 0x00,
                        ScanningFilterPolicy::WhiteListed => 0x01,
                        ScanningFilterPolicy::AcceptAllExceptIdentityNotAddressed => 0x02,
                        ScanningFilterPolicy::AcceptAllExceptIdentityNotInWhitelist => 0x03,
                    }
                }
            }

            impl Default for ScanningFilterPolicy {
                fn default() -> Self {
                    ScanningFilterPolicy::AcceptAll
                }
            }

            pub struct ScanningParameters {
                pub scan_type: LEScanType,
                pub scan_interval: ScanningInterval,
                pub scan_window: ScanningWindow,
                pub own_address_type: OwnAddressType,
                pub scanning_filter_policy: ScanningFilterPolicy,
            }

            impl Default for ScanningParameters {
                fn default() -> Self {
                    ScanningParameters {
                        scan_type: LEScanType::default(),
                        scan_interval: ScanningInterval::default(),
                        scan_window: ScanningWindow::default(),
                        own_address_type: OwnAddressType::default(),
                        scanning_filter_policy: ScanningFilterPolicy::default(),
                    }
                }
            }

            impl_status_return!(COMMAND);

            #[repr(packed)]
            pub(crate) struct CmdParameter {
                _scan_type: u8,
                _scan_interval: u16,
                _scan_window: u16,
                _own_address_type: u8,
                _filter_policy: u8,
            }

            impl CommandParameters for ScanningParameters {
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    CmdParameter {
                        _scan_type:        self.scan_type.into_val(),
                        _scan_interval:    self.scan_interval.get_raw_val(),
                        _scan_window:      self.scan_window.get_raw_val(),
                        _own_address_type: self.own_address_type.into_val(),
                        _filter_policy:    self.scanning_filter_policy.into_val(),
                    }
                }
            }

            pub fn send( hci: &HostInterface, sp: ScanningParameters )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(sp, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use std::time::Duration;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn scanning_interval_test() {
                    ScanningInterval::try_from_raw(0x0004).unwrap();
                    ScanningInterval::try_from_raw(0x4000).unwrap();
                    ScanningInterval::try_from_raw(0x0003).unwrap_err();
                    ScanningInterval::try_from_raw(0x4001).unwrap_err();
                    ScanningInterval::try_from_duration(Duration::from_micros(2500)).unwrap();
                    ScanningInterval::try_from_duration(Duration::new(10,240000000)).unwrap();
                    ScanningInterval::try_from_duration(Duration::from_nanos(2499999)).unwrap_err();
                    ScanningInterval::try_from_duration(Duration::new(10,240000001)).unwrap_err();
                }

                #[test]
                fn set_scan_parameters_test() {

                    let parameters = ScanningParameters::default();

                    block_for_result(send(&HostInterface::default(), parameters)).unwrap();

                }
            }
        }
    }

    pub mod connection {

        pub struct ConnectionEventLength {
            minimum: u16,
            maximum: u16,
        }

        impl ConnectionEventLength {
            pub fn new(min: u16, max: u16) -> Self {
                Self {
                    minimum: min,
                    maximum: max
                }
            }
        }

        impl ::core::default::Default for ConnectionEventLength {
            fn default() -> Self {
                Self {
                    minimum: 0,
                    maximum: 0xFFFF,
                }
            }
        }

        interval!( #[derive(Clone, Copy)] ConnectionInterval, 0x0006, 0x0C80, ApiDef, 0x0006, 1250);

        /// ConnectionUpdateInterval contaings the minimum and maximum connection intervals for
        /// the le connection update
        pub struct ConnectionIntervalBounds {
            min: ConnectionInterval,
            max: ConnectionInterval,
        }

        impl ConnectionIntervalBounds {
            /// Create a ConnectionUpdateInterval
            ///
            /// # Errors
            /// An error is returned if the minimum is greater then the maximum
            pub fn try_from(min: ConnectionInterval, max: ConnectionInterval)
                -> Result<Self,&'static str>
            {
                if min.get_raw_val() <= max.get_raw_val() {
                    Ok( Self {
                        min: min,
                        max: max,
                    })
                }
                else {
                    Err("'min' is greater than 'max'")
                }
            }
        }

        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod disconnect {
            use crate::hci::*;
            use crate::hci::common::ConnectionHandle;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LinkControl(opcodes::LinkControl::Disconnect);

            /// These are the error codes that are given as reasons for disconnecting
            ///
            /// These enumerations are the acceptable error codes to be used as reasons for
            /// triggering the disconnect.
            pub enum DisconnectReason {
                AuthenticationFailure,
                RemoteUserTerminatedConnection,
                RemoteDeviceTerminatedConnectionDueToLowResources,
                RemoteDeviceTerminatedConnectionDueToPowerOff,
                UnsupportedRemoteFeature,
                PairingWithUnitKeyNotSupported,
                UnacceptableConnectionParameters,
            }

            impl DisconnectReason {

                // TODO implement when HCI error codes are added, and add parameter for the
                // error enumeraton name
                pub fn try_from_hci_error( error: error::Error ) -> Result<DisconnectReason, &'static str> {
                    match error {
                        error::Error::AuthenticationFailure => {
                            Ok(DisconnectReason::AuthenticationFailure)
                        }
                        error::Error::RemoteUserTerminatedConnection => {
                            Ok(DisconnectReason::RemoteUserTerminatedConnection)
                        }
                        error::Error::RemoteDeviceTerminatedConnectionDueToLowResources => {
                            Ok(DisconnectReason::RemoteDeviceTerminatedConnectionDueToLowResources)
                        }
                        error::Error::RemoteDeviceTerminatedConnectionDueToPowerOff => {
                            Ok(DisconnectReason::RemoteDeviceTerminatedConnectionDueToPowerOff)
                        }
                        error::Error::UnsupportedRemoteFeatureOrUnsupportedLMPFeature => {
                            Ok(DisconnectReason::UnsupportedRemoteFeature)
                        }
                        error::Error::PairingWithUnitKeyNotSupported => {
                            Ok(DisconnectReason::PairingWithUnitKeyNotSupported)
                        }
                        error::Error::UnacceptableConnectionParameters => {
                            Ok(DisconnectReason::UnacceptableConnectionParameters)
                        }
                        _ => {
                            Err("No Disconnect reason for error")
                        }
                    }
                }

                fn get_val(&self) -> u8 {
                    match *self {
                        DisconnectReason::AuthenticationFailure => 0x05,
                        DisconnectReason::RemoteUserTerminatedConnection => 0x13,
                        DisconnectReason::RemoteDeviceTerminatedConnectionDueToLowResources => 0x14,
                        DisconnectReason::RemoteDeviceTerminatedConnectionDueToPowerOff => 0x15,
                        DisconnectReason::UnsupportedRemoteFeature => 0x1A,
                        DisconnectReason::PairingWithUnitKeyNotSupported => 0x29,
                        DisconnectReason::UnacceptableConnectionParameters => 0x3B,
                    }
                }
            }

            #[repr(packed)]
            pub(crate) struct CmdParameter {
                _handle: u16,
                _reason: u8,
            }

            pub struct DisconnectParameters {
                pub connection_handle: ConnectionHandle,
                pub disconnect_reason: DisconnectReason,
            }

            impl CommandParameters for DisconnectParameters {
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    CmdParameter {
                        _handle: self.connection_handle.get_raw_handle(),
                        _reason: self.disconnect_reason.get_val(),
                    }
                }
            }

            impl_command_status_future!();

            pub fn send( hci: &HostInterface, dp: DisconnectParameters )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(dp, events::Events::CommandStatus, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                fn disconnect_test() {
                    // should be a random, unused handle
                    let handle = ConnectionHandle::try_from(0x123).unwrap();

                    let reason = DisconnectReason::AuthenticationFailure;

                    let parameters = DisconnectParameters {
                        connection_handle: handle,
                        disconnect_reason: reason,
                    };


                    block_for_result(send(&HostInterface::default(), parameters)).unwrap_err();
                }
            }
        }
        pub mod connection_update {
            use crate::hci::*;
            use crate::hci::common::{
                ConnectionHandle,
                SupervisionTimeout,
            };
            use super::{ ConnectionEventLength, ConnectionIntervalBounds };

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ConnectionUpdate);

            #[repr(packed)]
            pub(crate) struct CmdParameter {
                _handle: u16,
                _conn_interval_min: u16,
                _conn_interval_max: u16,
                _conn_latency: u16,
                _supervision_timeout: u16,
                _minimum_ce_length: u16,
                _maximum_ce_length: u16,
            }

            pub struct ConnectionUpdate {
                pub handle: ConnectionHandle,
                pub interval: ConnectionIntervalBounds,
                pub latency: u16,
                pub supervision_timeout: SupervisionTimeout,
                pub connection_event_len: ConnectionEventLength,
            }


            impl CommandParameters for ConnectionUpdate {
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    CmdParameter {
                        _handle:              self.handle.get_raw_handle(),
                        _conn_interval_min:   self.interval.min.get_raw_val(),
                        _conn_interval_max:   self.interval.max.get_raw_val(),
                        _conn_latency:        self.latency,
                        _supervision_timeout: self.supervision_timeout.get_timeout(),
                        _minimum_ce_length:   self.connection_event_len.minimum,
                        _maximum_ce_length:   self.connection_event_len.maximum,
                    }
                }
            }

            impl_returned_future!(
                crate::hci::events::LEConnectionUpdateCompleteData,
                events::EventsData::LEMeta,
                events::LEMetaData::ConnectionUpdateComplete(data),
                &'static str, // useless type that has both Display + Debug
                {
                    core::task::Poll::Ready(Ok(data))
                }
            );

            /// The event expected to be returned is the LEMeta event carrying a Connection Update
            /// Complete lE event
            pub fn send( hci: &HostInterface, cu: ConnectionUpdate, timeout: Duration)
            -> impl Future<Output=Result<crate::hci::events::LEConnectionUpdateCompleteData, impl Display + Debug>> {
                ReturnedFuture( hci.send_command( cu, events::Events::LEMeta( events::LEMeta::ConnectionUpdateComplete ), timeout ) )
            }

            #[cfg(test)]
            mod tests {

                use super::*;
                use crate::hci::common;
                use super::super::ConnectionInterval;
                use crate::hci::test_util::block_for_result;

                /// This will likely fail with a timeout due to there being no connection to
                /// a device.
                #[test]
                #[ignore]
                fn connection_update_test() {

                    let timeout = Duration::from_secs(1);

                    let parameter = ConnectionUpdate {
                        handle: ConnectionHandle::try_from(0x0033).unwrap(),
                        interval: ConnectionIntervalBounds::try_from(
                            ConnectionInterval::try_from_raw(0x100).unwrap(),
                            ConnectionInterval::try_from_raw(0x100).unwrap()
                        ).unwrap(),
                        latency: 0x1000,
                        supervision_timeout: common::SupervisionTimeout::try_from_raw(0x234).unwrap(),
                        connection_event_len: ConnectionEventLength::new(0, 0xFFFF)
                    };

                    let result = block_for_result(send(&HostInterface::default(), parameter, timeout))
                        .unwrap();

                    if let error::Error::NoError = error::Error::from(result.status) {
                        panic!("Expected Error because no connection is made");
                    }
                }
            }
        }
        pub mod create_connection_cancel {

            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::CreateConnectionCancel);

            impl_status_return!(COMMAND);

            #[derive(Clone,Copy)]
            struct Parameter;

            impl CommandParameters for Parameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            pub fn send( hci: &HostInterface)
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command( Parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {

                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                #[ignore]
                fn create_connection_cancel_test() {

                    block_for_result(send(&HostInterface::default())).unwrap();

                }
            }
        }
        pub mod create_connection {

            use super::{ConnectionEventLength, ConnectionIntervalBounds};
            use crate::hci::*;
            use crate::hci::common::{
                ConnectionLatency,
                LEAddressType,
                SupervisionTimeout,
            };
            use crate::hci::le::common::OwnAddressType;
            use core::time::Duration;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::CreateConnection);

            interval!(ScanningInterval, 0x0004, 0x4000, SpecDef, 0x0010, 625);
            interval!(ScanningWindow, 0x0004, 0x4000, SpecDef, 0x0010, 625);

            pub enum InitiatorFilterPolicy {
                DoNotUseWhiteList,
                UseWhiteList,
            }

            impl InitiatorFilterPolicy {
                fn into_raw(&self) -> u8 {
                    match *self {
                        InitiatorFilterPolicy::DoNotUseWhiteList => 0x00,
                        InitiatorFilterPolicy::UseWhiteList => 0x01,
                    }
                }
            }

            pub struct ConnectionParameters {
                scan_interval : ScanningInterval,
                scan_window : ScanningWindow,
                initiator_filter_policy: InitiatorFilterPolicy,
                peer_address_type: LEAddressType,
                peer_address: crate::BluetoothDeviceAddress,
                own_address_type: OwnAddressType,
                connection_interval: ConnectionIntervalBounds,
                connection_latency: ConnectionLatency,
                supervision_timeout: SupervisionTimeout,
                connection_event_len: ConnectionEventLength,
            }

            #[repr(packed)]
            pub(crate) struct CmdParameter {
                _scan_interval: u16,
                _scan_window: u16,
                _initiator_filter_policy: u8,
                _peer_address_type: u8,
                _peer_address: crate::BluetoothDeviceAddress,
                _own_address_type: u8,
                _conn_interval_min: u16,
                _conn_interval_max: u16,
                _conn_latency: u16,
                _supervision_timeout: u16,
                _minimum_ce_length: u16,
                _maximum_ce_length: u16,
            }

            impl CommandParameters for ConnectionParameters {
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    CmdParameter {
                        _scan_interval:           self.scan_interval.get_raw_val(),
                        _scan_window:             self.scan_window.get_raw_val(),
                        _initiator_filter_policy: self.initiator_filter_policy.into_raw(),
                        _peer_address_type:       self.peer_address_type.into_raw(),
                        _peer_address:            self.peer_address,
                        _own_address_type:        self.own_address_type.into_val(),
                        _conn_interval_min:       self.connection_interval.min.get_raw_val(),
                        _conn_interval_max:       self.connection_interval.max.get_raw_val(),
                        _conn_latency:            self.connection_latency.get_latency(),
                        _supervision_timeout:     self.supervision_timeout.get_timeout(),
                        _minimum_ce_length:       self.connection_event_len.minimum,
                        _maximum_ce_length:       self.connection_event_len.maximum,
                    }
                }
            }

            impl ConnectionParameters {

                /// Command Parameters for connecting without the white list
                pub fn new_without_whitelist(
                    scan_interval : ScanningInterval,
                    scan_window : ScanningWindow,
                    peer_address_type: LEAddressType,
                    peer_address: crate::BluetoothDeviceAddress,
                    own_address_type: OwnAddressType,
                    connection_interval: ConnectionIntervalBounds,
                    connection_latency: ConnectionLatency,
                    supervision_timeout: SupervisionTimeout,
                    connection_event_len: ConnectionEventLength,
                ) -> Self {
                    Self {
                        scan_interval : scan_interval,
                        scan_window : scan_window,
                        initiator_filter_policy: InitiatorFilterPolicy::DoNotUseWhiteList,
                        peer_address_type : peer_address_type,
                        peer_address : peer_address,
                        own_address_type : own_address_type,
                        connection_interval : connection_interval,
                        connection_latency : connection_latency,
                        supervision_timeout : supervision_timeout,
                        connection_event_len : connection_event_len,
                    }
                }

                /// Command parameters for connecting with the white list
                pub fn new_with_whitelist(
                    scan_interval : ScanningInterval,
                    scan_window : ScanningWindow,
                    own_address_type: OwnAddressType,
                    connection_interval: ConnectionIntervalBounds,
                    connection_latency: ConnectionLatency,
                    supervision_timeout: SupervisionTimeout,
                    connection_event_len: ConnectionEventLength,
                ) -> Self {
                    Self {
                        scan_interval : scan_interval,
                        scan_window : scan_window,
                        initiator_filter_policy: InitiatorFilterPolicy::UseWhiteList,
                        peer_address_type : LEAddressType::PublicDeviceAddress, // This is not used (see spec)
                        peer_address : [0u8;6], // This is not used (see spec)
                        own_address_type : own_address_type,
                        connection_interval : connection_interval,
                        connection_latency : connection_latency,
                        supervision_timeout : supervision_timeout,
                        connection_event_len : connection_event_len,
                    }
                }

            }

            impl_command_status_future!();

            pub fn send( hci: &HostInterface, cp: ConnectionParameters )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(cp, events::Events::CommandStatus , Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {
                #[test]
                #[ignore]
                fn create_connection_test() {
                    unimplemented!()
                }
            }
        }
        pub mod read_channel_map {

            use crate::hci::*;
            use crate::hci::common::ConnectionHandle;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReadChannelMap);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                connection_handle: u16,
                channel_map: [u8;5]
            }

            pub struct ChannelMapInfo {
                pub handle: ConnectionHandle,
                /// This is the list of channels (from 0 through 36)
                pub channel_map: ::alloc::boxed::Box<[usize]>,
            }

            impl ChannelMapInfo {
                fn try_from(packed: CmdReturn) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {

                        // 37 is the number of channels (as of bluetooth 5.0)
                        let channel_count = 37;

                        let mut count = 0;

                        let mut mapped_channels = Vec::with_capacity(channel_count);

                        'outer: for byte in packed.channel_map.iter() {
                            for bit in 0..8 {
                                if count < channel_count {
                                    if 0 != (byte & (1 << bit)) {
                                        mapped_channels.push(count);
                                        count += 1;
                                    }
                                }
                                else {
                                    break 'outer;
                                }
                            }
                        }

                        Ok( Self {
                            handle: ConnectionHandle::try_from(packed.connection_handle).unwrap(),
                            channel_map: mapped_channels.into_boxed_slice(),
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            #[repr(packed)]
            #[derive( Clone, Copy)]
            struct CmdParameter {
                _connection_handle: u16
            }

            impl CommandParameters for CmdParameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                ChannelMapInfo,
                error::Error
            );

            impl_command_data_future!(ChannelMapInfo, error::Error);

            pub fn send( hci: &HostInterface, handle: ConnectionHandle )
            -> impl Future<Output=Result<ChannelMapInfo, impl Display + Debug>>
            {

                let parameter = CmdParameter {
                    _connection_handle: handle.get_raw_handle()
                };

                ReturnedFuture( hci.send_command(parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {

                #[test]
                #[ignore]
                fn read_channel_map_test() {
                    unimplemented!()
                }
            }
        }
        pub mod read_remote_features {

            use crate::hci::*;
            use crate::hci::common::ConnectionHandle;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::ReadRemoteFeatures);

            #[repr(packed)]
            #[derive( Clone, Copy)]
            struct CmdParameter {
                _connection_handle: u16
            }

            impl CommandParameters for CmdParameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_command_status_future!();

            pub fn send( hci: HostInterface, handle: ConnectionHandle )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {

                let parameter = CmdParameter {
                    _connection_handle: handle.get_raw_handle(),
                };

                ReturnedFuture( hci.send_command(parameter, events::Events::CommandStatus, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {
                #[test]
                #[ignore]
                fn read_remote_features_test() {
                    unimplemented!()
                }
            }
        }
        pub mod set_host_channel_classification {
            use crate::hci::*;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LEController(opcodes::LEController::SetHostChannelClassification);

            #[repr(packed)]
            pub(crate) struct CmdParemeter {
                _channel_map: [u8;5]
            }

            const CHANNEL_MAP_MAX: usize = 37;

            pub struct ChannelMap {
                channels: [bool;CHANNEL_MAP_MAX]
            }

            impl ChannelMap {
                pub const MAX: usize = 37;

                /// try to create a Channel Map
                ///
                /// This will form a channel map so long as every value in slice referenced by
                /// channels is less then CHANNEL_MAP_MAX
                ///
                /// # Error
                /// A value in the parameter was found to be larger then CHANNEL_MAP_MAX
                pub fn try_from<'a>(channels: &'a[usize]) -> Result<Self, usize> {

                    let mut channel_flags = [false;CHANNEL_MAP_MAX];

                    for val in channels {
                        if *val < CHANNEL_MAP_MAX {
                            channel_flags[*val] = true;
                        }
                        else {
                            return Err(*val);
                        }
                    }

                    Ok( Self {
                        channels: channel_flags
                    })
                }
            }

            impl CommandParameters for ChannelMap {
                type Parameter = CmdParemeter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {

                    let mut raw = [0u8;5];

                    for val in 0..CHANNEL_MAP_MAX {
                        if self.channels[val] {
                            raw[val / 8] |= 1 << (val % 8)
                        }
                    }

                    CmdParemeter {
                        _channel_map : raw
                    }
                }
            }

            impl_status_return!(COMMAND);

            pub fn send( hci: HostInterface, map: ChannelMap )
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command( map, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod test {

                use super::*;

                #[test]
                #[ignore]
                fn set_host_channel_classification_test() {
                    unimplemented!()
                }

                #[test]
                fn channel_map_test() {
                    unimplemented!();
                    let _expected_raw_map = [
                        (1 << 3) | (1 << 7),
                        (1 << (9 - 8)) | (1 << (11 - 8)) | (1 << (13 - 8)),
                        0,
                        0,
                        0,
                    ];

                    let _map = ChannelMap::try_from(&[11,11,3,9,13,7]).unwrap();
                }
            }
        }
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod read_transmit_power_level {
            use crate::hci::*;
            use crate::hci::common::ConnectionHandle;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::ControllerAndBaseband(opcodes::ControllerAndBaseband::ReadTransmitPowerLevel);

            #[repr(packed)]
            pub(crate) struct CmdParameter {
                _connection_handle: u16,
                _level_type: u8,
            }

            #[repr(packed)]
            struct CmdReturn {
                status: u8,
                connection_handle: u16,
                power_level: i8,
            }

            /// Transmit power range (from minimum to maximum levels)
            pub struct TransmitPowerLevel {
                pub connection_handle: ConnectionHandle,
                pub power_level: i8,
            }

            impl TransmitPowerLevel {

                fn try_from(packed: CmdReturn) -> Result<Self, error::Error> {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok(Self {
                            // If this panics here the controller returned a bad connection handle
                            connection_handle: ConnectionHandle::try_from(packed.connection_handle).unwrap(),
                            power_level: packed.power_level,
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                TransmitPowerLevel,
                error::Error
            );

            impl_command_data_future!(TransmitPowerLevel, error::Error);

            pub enum TransmitPowerLevelType {
                CurrentPowerLevel,
                MaximumPowerLevel,
            }

            pub struct CommandParameter {
                pub connection_handle: ConnectionHandle,
                pub level_type: TransmitPowerLevelType,
            }

            impl CommandParameters for CommandParameter {
                type Parameter = CmdParameter;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter {
                    CmdParameter {
                        _connection_handle: self.connection_handle.get_raw_handle(),
                        _level_type: match self.level_type {
                            TransmitPowerLevelType::CurrentPowerLevel => 0,
                            TransmitPowerLevelType::MaximumPowerLevel => 1,
                        }
                    }
                }
            }

            pub fn send( hci: &HostInterface, parameter: CommandParameter )
            -> impl Future<Output=Result<TransmitPowerLevel, impl Display + Debug>>
            {
                ReturnedFuture( hci.send_command(parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {
                use super::*;
                use crate::hci::test_util::block_for_result;

                #[test]
                #[ignore]
                fn read_transmit_power_level_test() {
                    let parameter = CommandParameter {
                        connection_handle: ConnectionHandle::try_from(0x00FF).unwrap(),
                        level_type: TransmitPowerLevelType::CurrentPowerLevel,
                    };

                    block_for_result(send(&HostInterface::default(), parameter)).unwrap();

                }
            }
        }
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod read_remote_version_information {

            use crate::hci::*;
            use crate::hci::common::ConnectionHandle;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::LinkControl(opcodes::LinkControl::ReadRemoteVersionInformation);

            #[repr(packed)]
            #[derive( Clone, Copy)]
            struct CmdParameter {
                _connection_handle: u16
            }

            impl CommandParameters for CmdParameter {
                type Parameter = Self;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { *self }
            }

            impl_command_status_future!();

            pub fn send( hci: &HostInterface, handle: ConnectionHandle)
            -> impl Future<Output=Result<(), impl Display + Debug>>
            {

                let parameter = CmdParameter {
                    _connection_handle: handle.get_raw_handle()
                };

                ReturnedFuture( hci.send_command(parameter, events::Events::CommandStatus, Duration::from_secs(1) ) )
            }

            #[cfg(test)]
            mod tests {

                #[test]
                #[ignore]
                fn read_remote_version_information_test() {
                    unimplemented!()
                }
            }
        }
        // TODO when BR/EDR is enabled move this to a module for common features and import here
        pub mod read_rssi {

            use crate::hci::*;
            use crate::hci::common::ConnectionHandle;

            const COMMAND: opcodes::HCICommand = opcodes::HCICommand::StatusParameters(opcodes::StatusParameters::ReadRSSI);

            #[repr(packed)]
            pub(crate) struct CmdReturn {
                status: u8,
                handle: u16,
                rssi: i8
            }

            struct Parameter {
                handle: u16
            }

            impl CommandParameters for Parameter {
                type Parameter = u16;
                const COMMAND: opcodes::HCICommand = COMMAND;
                fn get_parameter(&self) -> Self::Parameter { self.handle }
            }

            pub struct RSSIInfo {
                pub handle: ConnectionHandle,
                pub rssi: i8
            }

            impl RSSIInfo {
                fn try_from(packed: CmdReturn) -> Result<Self, error::Error > {
                    let status = error::Error::from(packed.status);

                    if let error::Error::NoError = status {
                        Ok( Self {
                            handle: ConnectionHandle::try_from(packed.handle).unwrap(),
                            rssi: packed.rssi
                        })
                    }
                    else {
                        Err(status)
                    }
                }
            }

            impl_get_data_for_command!(
                COMMAND,
                CmdReturn,
                RSSIInfo,
                error::Error
            );

            impl_command_data_future!(RSSIInfo, error::Error);

            pub fn send( hci: &HostInterface, handle: ConnectionHandle )
            -> impl Future<Output=Result<RSSIInfo, impl Display + Debug>>
            {
                let parameter = Parameter {
                    handle: handle.get_raw_handle()
                };

                ReturnedFuture( hci.send_command(parameter, events::Events::CommandComplete, Duration::from_secs(1) ) )
            }
        }
    }
//
//     pub mod br_edr {
//         // TODO does this module make sense?
//         pub mod support {
//             pub fn read_le_host() { unimplemented!() }
//             pub fn write_le_host() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn read_buffer_size() { unimplemented!() }
//         }
//     }
//
//     pub mod scannable {
//         pub mod command {
//             pub fn set_scan_response_data() { unimplemented!() }
//         }
//     }
//
//     pub mod encryption {
//         pub mod event {
//             pub fn encryption_change() { unimplemented!() }
//             pub fn encryption_key_refresh_complete() { unimplemented!() }
//             pub fn long_term_key_request() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn encrypt() { unimplemented!() }
//             pub fn long_term_key_request_reply() { unimplemented!() }
//             pub fn long_term_key_request_negative_reply() { unimplemented!() }
//             pub fn rand() {unimplemented!()}
//             pub fn start_encryption() { unimplemented!() }
//         }
//     }
//
//     pub mod connection_parameters_request_procedure {
//         pub mod event {
//             pub fn remote_connection_paramter_request() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn remote_connection_parameter_request_reply() { unimplemented!() }
//             pub fn remote_connection_parameter_request_negative_reply() { unimplemented!() }
//         }
//     }
//
//     pub mod ping {
//         pub mod event {
//             pub fn authenticated_payload_timeout_expired() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn write_authenticated_payload_timeout() { unimplemented!() }
//             pub fn read_authenticated_payload_timeout() { unimplemented!() }
//             pub fn set_event_mask_page_2() { unimplemented!() }
//         }
//     }
//
//     pub mod data_packet_length_extension {
//         pub mod event {
//             pub fn data_length_change() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_data_length() { unimplemented!() }
//             pub fn read_suggested_default_data_length() { unimplemented!() }
//             pub fn write_suggested_default_data_length() { unimplemented!() }
//         }
//     }
//
//     pub mod privacy {
//         pub mod event {
//             pub fn directed_advertising_report() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_resolvable_private_address_timeout() { unimplemented!() }
//             pub fn set_address_resolution_enable() { unimplemented!() }
//             pub fn add_device_to_resolving_list() { unimplemented!() }
//             pub fn clear_resolving_list() { unimplemented!() }
//             pub fn set_privacy_mode() { unimplemented!() }
//             pub fn read_peer_resolvable_address() { unimplemented!() }
//             pub fn read_local_resolvable_address() { unimplemented!() }
//         }
//     }
//
//     pub mod phy_2m_or_coded {
//         pub mod event {
//             pub fn phy_update_complete() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn read_phy() { unimplemented!() }
//             pub fn set_default_phy() { unimplemented!() }
//             pub fn set_phy() { unimplemented!() }
//             pub fn enhanced_transmitter_test() { unimplemented!() }
//             pub fn enhanced_receiver_test() { unimplemented!() }
//         }
//     }
//
//     pub mod extended_advertising {
//         pub mod event {
//             pub fn scan_request_received() { unimplemented!() }
//             pub fn advertising_set_terminated() { unimplemented!() }
//             pub fn scan_timeout() { unimplemented!() }
//             pub fn extended_advertising_report() { unimplemented!() }
//         }
//         pub mod legacy_event {
//             /// Superseded by extended_advertising_report
//             pub fn advertising_report() { unimplemented!() }
//             /// Superseded by exted_advertising_report
//             pub fn direted_advertising_report() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_advertising_set_random_address() { unimplemented!() }
//             pub fn set_extended_advertising_parameters() { unimplemented!() }
//             pub fn set_extended_advertising_data() { unimplemented!() }
//             pub fn set_extended_scan_response_data() { unimplemented!() }
//             pub fn set_extended_advertising_enable() { unimplemented!() }
//             pub fn read_maximum_advertising_data_length() { unimplemented!() }
//             pub fn read_number_of_supported_advertising_sets() { unimplemented!() }
//             pub fn remove_advertising_set() { unimplemented!() }
//             pub fn clear_advertisisng_sets() { unimplemented!() }
//             pub fn set_extended_scan_parameters() { unimplemented!() }
//             pub fn set_extended_scan_enable() { unimplemented!() }
//             pub fn extended_create_connection() { unimplemented!() }
//         }
//         pub mod legacy_command {
//             /// Superseded by set_extended_advertising_parameters
//             pub fn set_advertising_parameters() { unimplemented!() }
//             /// No longer used
//             pub fn read_advertising_channel_tx_power() { unimplemented!() }
//             /// Superseded by set_extended_advertising_data
//             pub fn set_advertising_data() { unimplemented!() }
//             /// Superseded by set_extended_advertising_enable
//             pub fn set_scan_parameters() { unimplemented!() }
//             /// Superseded by set_extended_scan_enable
//             pub fn set_scan_enable() { unimplemented!() }
//             /// Superseded by extended_create_connection
//             pub fn extended_create_connection() { unimplemented!() }
//         }
//     }
//
//     pub mod periodic_advertising {
//         pub mod event {
//             pub fn periodic_advertising_report() { unimplemented!() }
//             pub fn periodic_advertising_sync_established() { unimplemented!() }
//             pub fn periodic_advertising_sync_lost() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn set_periodic_advertising_parameters() { unimplemented!() }
//             pub fn set_periodic_advertising_data() { unimplemented!() }
//             pub fn set_periodic_advertising_enable() { unimplemented!() }
//             pub fn periodic_advertising_create_sync() { unimplemented!() }
//             pub fn periodic_advertising_create_sync_cancel() { unimplemented!() }
//             pub fn periodic_advertising_terminate_sync() { unimplemented!() }
//             pub fn add_device_to_periodic_advertising_list() { unimplemented!() }
//             pub fn remove_device_from_periodic_advertiser_list() { unimplemented!() }
//             pub fn clear_periodic_advertiser_list() { unimplemented!() }
//             pub fn read_periodic_advertiser_list_size() { unimplemented!() }
//         }
//     }
//
//     pub mod advertising_of_tx_power {
//         pub mod command {
//             pub fn read_rf_path_compensation() { unimplemented!() }
//             pub fn write_rf_path_compensation() { unimplemented!() }
//         }
//     }
//
//     pub mod channel_selection_algorithm_2 {
//         pub mod event {
//             pub fn chennel_selection_algorithm() { unimplemented!() }
//         }
//     }
//
//     pub mod other {
//         pub mod event {
//             pub fn data_buffer_overflow() { unimplemented!() }
//             pub fn hardware_error() { unimplemented!() }
//             pub fn read_local_p256_public_key_complete() { unimplemented!() }
//             pub fn generate_dh_key_complete() { unimplemented!() }
//         }
//         pub mod command {
//             pub fn host_buffer_size() { unimplemented!() }
//             pub fn host_number_of_completed_packets() { unimplemented!() }
//             pub fn le_read_transmit_power() { unimplemented!() }
//             pub fn le_read_p256_public_key() { unimplemented!() }
//             pub fn generate_dh_key() { unimplemented!() }
//         }
//     }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn host_interface_default_test() {
        HostInterface::default();
    }
}
